-------------------------
#include <bits/stdc++.h>

void setZeros(vector<vector<int>> &matrix)
{
	// Write your code here.
	set<int>r, c;
	for(int i=0; i<matrix.size(); i++){
		for(int j=0; j<matrix[0].size(); j++){
			if(matrix[i][j]==0){
				r.insert(i);
				c.insert(j);
			}
		}
	}
	for(auto& q: r){
		for(int i=0; i<matrix[0].size(); i++){
			matrix[q][i]=0;
		}
	}
	for(auto& q: c){
		for(int i=0; i<matrix.size(); i++){
			matrix[i][q]=0;
		}
	}
	
}
-------------------------
#include <bits/stdc++.h>

vector<vector<long long int>> printPascal(int n) 
{
  // Write your code here.
  vector<vector<long long int>>v;
  for(int i=0; i<n; i++){
    vector<long long int>vv;
    for(int j=0; j<=i; j++){
      if(j==0 or j==i){
        vv.push_back(1);
      }
      else{
        vv.push_back(v[i-1][j-1]+v[i-1][j]);
      }
    }
    v.push_back(vv);

  }
  return v;
}

---------------
#include <bits/stdc++.h> 
vector<int> nextPermutation(vector<int> &nums, int n)
{
    //  Write your code here.
    int i;
    for ( i = n - 1; i >= 0; i--) {
      if (nums[i]>nums[i-1]) break;
    }
    if(i==0){
        reverse(nums.begin(),nums.end());
        return nums;
    }
    for(int j=n-1;j>=0;j--){
        if(nums[j]>nums[i-1]){
            swap(nums[j],nums[i-1]);
            sort(nums.begin()+i,nums.end());
            break;
        }
    }
    return nums;
}
-----------------------
#include <bits/stdc++.h> 
long long max(long long a, long long b){
    return a>b?a:b;
}
long long s(int arr[], int n, int i, vector<long long>&dp){
if(i==n){
    return 0;
}
if(dp[i]!=-1){
    return dp[i];
}
long long a=s(arr, n, i+1, dp);
return dp[i]=max(arr[i]+a, arr[i]);
}
long long maxSubarraySum(int arr[], int n)
{
    /*
        Don't write main().
        Don't read input, it is passed as function argument.    
        No need to print anything.
        Taking input and printing output is handled automatically.
    */
    long long ans=INT_MIN;
    vector<long long>dp(n, -1);
    for(int i=0; i<n; i++){
        ans=max(ans, s(arr, n, i, dp));
    }
return ans>0?ans:0;
}
-----------------
#include <bits/stdc++.h> 
void sort012(int *arr, int n)
{
   //   Write your code here
   int *l=arr+n-1;
   while(*l==2){
      l--;
   }
   int *i=arr;
   while(i<=l){
      if(*i==2){
         swap(*i, *l);
         l--;
          while(*l==2){
      l--;
   }
      }
      i++;
   }
   while(*l==1){
      l--;
   }
    i=arr;
   while(i<=l){
      if(*i==1){
         swap(*i, *l);
         l--;
          while(*l==1){
      l--;
   }
      }
      i++;
   }
}
-----------------
#include <bits/stdc++.h> 
int maximumProfit(vector<int> &prices){
    // Write your code here.
   int a=0;

int m=prices[0];
for(int i=0;i<prices.size();i++)
{
m=min(m,prices[i]);
int p=prices[i]-m;
a=max(a,p);
}
return a;
}
------------
#include <bits/stdc++.h>

void rotateMatrix(vector<vector<int>> &mat, int n, int m)
{
    // Write your code here
int i,j,left,right,top,bottom,k,temp;

     left=0;top=0;right=m-1;bottom=n-1;

     while(top<bottom&&left<right)

     {

         temp=mat[top][left];

         for(i=left+1;i<=right;i++)

         {

             k= mat[top][i];

             mat[top][i]=temp;

             temp=k;

         }

         top++;

         for(i=top;i<=bottom;i++)

         {

                k=mat[i][right];

                mat[i][right]=temp;

                temp=k;

 

         }

         right--;

         for(i=right;i>=left;i--)

         {

             k=mat[bottom][i];

             mat[bottom][i]=temp;

             temp=k;

         }

         bottom--;

         for(i=bottom;i>=top;i--)

         {

             k=mat[i][left];

             mat[i][left]=temp;

             temp=k;

         }

         left++;

         mat[top-1][left-1]=temp;

     }
}
-------------------
#include <bits/stdc++.h> 
/*

    intervals[i][0] = start point of i'th interval
    intervals[i][1] = finish point of i'th interval

*/

vector<vector<int>> mergeIntervals(vector<vector<int>> &inter)
{
    // Write your code here.
    sort(inter.begin(), inter.end());
    vector<vector<int>>n;
    vector<int>nn(2);
    nn[0]=inter[0][0];
    nn[1]=inter[0][1];
    n.push_back(nn);
    int ps=0, pe=nn[1];

    for(int i=1; i<inter.size(); i++){
        if(inter[i][0]<=pe){
            if(inter[i][1]>pe){
                pe=inter[i][1];
                n[ps][1]=pe;
            }
        }
        else{
             vector<int>nj(2);
    nj[0]=inter[i][0];
    nj[1]=inter[i][1];
    n.push_back(nj);
    pe=inter[i][1];
            ps++;

        }
    }
    return n;
}

---------
#include <bits/stdc++.h>

vector<int> ninjaAndSortedArrays(vector<int>& arr1, vector<int>& arr2, int m, int n) {
	// Write your code here.
	vector<int>v;
	for(int i=0; i<arr1.size(); i++){
		if(arr1[i]==0){
			break;
		}
		v.push_back(arr1[i]);
	}
	for(int i=0; i<arr2.size(); i++){
		
		v.push_back(arr2[i]);
	}
	sort(v.begin(), v.end());
	return v;
}
----------
#include <bits/stdc++.h>

int findDuplicate(vector<int> &arr, int n){
	// Write your code here.
	unordered_map<int,int>m;
	for(int i=0; i<n; i++){
		m[arr[i]]++;
		if(m[arr[i]]>1){
			return arr[i];
		}
	}
	
}

---------------
#include <bits/stdc++.h>

pair<int,int> missingAndRepeating(vector<int> &arr, int n)
{
	// Write your code here 
	unordered_map<int,int>m;
	int ans=-1;
	for(int i=0; i<n; i++){
		m[arr[i]]++;
		if(m[arr[i]]>1){
			ans=arr[i];
		}
	}
	for(int i=1; i<=n; i++){
		if(m[i]==0){
                  return { i, ans };
                }
	}
	
}

---------------
#include <bits/stdc++.h> 
long long getInversions(long long *arr, int n){
     int  cnt=0;

    for(int i=0;i<n;i++)

    {

        for(int j=i+1;j<n;j++)

        {

            if(arr[i]>arr[j])

            {

                cnt++;

            }

        }

    }

    return cnt;


}
-----------------
#include<bits/stdc++.h>
bool bs(vector<vector<int>>& mat, int tar, int m){
        int s=0, e=mat[m].size()-1, mid;
        while(s<=e){
                mid=s+(e-s)/2;
                if(mat[m][mid]==tar){
                        return true;
                }
                else if(mat[m][mid]>tar){
                        e=mid-1;
                }
                else{
                        s=mid+1;
                }
        }
        return false;
}
bool searchMatrix(vector<vector<int>>& mat, int tar) {
        
        int s=0, e=mat.size()-1, m;
        while(s<=e){
                 m=s+(e-s)/2;
                if(tar>=mat[m][0] and tar<=mat[m][mat[0].size()-1]){
                        return bs(mat, tar, m);
                }
                else if(tar<mat[m][0]){
                        e=m-1;
                }
                else if(tar>mat[m][mat[0].size()-1]){
                        s=m+1;
                }
        }
        return false;
}
----------------
#include <bits/stdc++.h>

int modularExponentiation(int x, int n, int m) {
	// Write your code here.
	long ans=1;

long xx=x;

while(n>0)

{

    if(n%2)

    {

        ans=((ans)%m*(xx)%m)%m;

    }

    xx=((xx)%m*(xx)%m)%m;

    n=n>>1;

}

return (int)(ans%m);
}
--------------------
#include <bits/stdc++.h>

int findMajorityElement(int arr[], int n) {
	// Write your code here.
	unordered_map<int,int>m;
	int ans=-1;
	for(int i=0; i<n; i++){
		m[arr[i]]++;
		if(m[arr[i]]>(n/2)){
			ans=arr[i];
		}
	}
	return ans;
}
----------------
#include <bits/stdc++.h>

vector<int> majorityElementII(vector<int> &arr)
{
    // Write your code here.
    unordered_map<int,int>m;
    sort(arr.begin(), arr.end());
    vector<int>v;
    int n=arr.size();
    for(int i=0; i<n; i++){
        m[arr[i]]++;
        if(m[arr[i]]>(n/3) and (v.empty() or v.back()!=arr[i])){
            v.push_back(arr[i]);
        }
    }
    return v;

}
---------------
#include <bits/stdc++.h> 
int sol(int m, int n, int& mm, int& nn, vector<vector<int>>&dp){
	if(m==mm and n==nn){
		return 1;  
	}
	if(m>mm or n>nn){
		return 0;
	}
	if(dp[m][n]!=-1){
		return dp[m][n];
	}
	return dp[m][n]=sol(m+1, n, mm, nn, dp)+sol(m, n+1, mm, nn, dp);
}
int uniquePaths(int m, int n) {
	// Write your code here.
	--m;
	--n;
	vector<vector<int>>dp(m+1, vector<int>(n+1, -1));
	return sol(0, 0, m, n, dp);
}
---------------------------
#include <bits/stdc++.h> 
void merge(vector<int>&arr,int lo,int mid,int hi){
	vector<int>temp;
	int left = lo;
	int right = mid+1;
	
	while(left<=mid && right<=hi){
		if(arr[left]<arr[right]){
		temp.push_back(arr[left]);
		left++;
	}
	else{
		temp.push_back(arr[right]);
		right++;
	}
}

	while(left<=mid){
		temp.push_back(arr[left]);
		left++;
	}
	while(right<=hi){
		temp.push_back(arr[right]);
		right++;
	}
	
	for(int i=lo;i<=hi;i++){
		arr[i] = temp[i-lo];
	}
}
int countPairs(vector<int>&arr,int lo,int mid,int hi){
	int right = mid+1;
	int cnt =0;
	for(int i=lo;i<=mid;i++){
		while(right<=hi && arr[i]>2*arr[right])
		right++;
		cnt+=(right-(mid+1));
	}
	return cnt;
}

int mergeSort(vector<int>&arr,int lo,int hi){
	int cnt =0;
	if(lo>=hi)
		return cnt;
	int mid = (lo+hi)/2;
	cnt+=mergeSort(arr,lo,mid);
	cnt+=mergeSort(arr,mid+1,hi);
	cnt+=countPairs(arr,lo,mid,hi);
	merge(arr,lo,mid,hi);
	return cnt;
}

int reversePairs(vector<int> &arr, int n){
	return mergeSort(arr,0,n-1);
}
---------------------
#include <bits/stdc++.h>

vector<vector<int>> pairSum(vector<int> &arr, int s){
   // Write your code here.
   sort(arr.begin(), arr.end());
   vector<vector<int>>v;
   int i=0, j=arr.size()-1;
   while(i<j){
      if(arr[i]+arr[j]==s){
        // v.push_back({arr[i], arr[j]});
         int k=i;
         int c=0, t=0;
         while(arr[k]==arr[i]){
            c++;
            k++;

         }
         k=j;
         int l=k;
while(arr[k]==arr[j] ){
            t++;
            k--;

         }
         int t1=i;
         int t2=j;
         i+=c;
         j-=t;
         t*=c;
         if(arr[t1]==arr[t2]){
            t=0;
            for(c=t1; c<=t2; c++){
               t++;
            }
            int sm=0;
            for(int y=1; y<=t; y++){
               sm+=(t-y);
            }
            t=sm;
         }
         while(t){
            v.push_back({arr[t1], arr[t2]});
            t--;
         }
         

      }
      else if(arr[i]+arr[j]>s){
         j--;
      }
      else{
         i++;
      }
   }
   return v;
}
-------------------------
#include <bits/stdc++.h>

string fourSum(vector<int> arr, int target, int n) {
    // Write your code here.
     map<long long, pair<int,int>>mp;
    for(int i=0;i<n;i++){
        for(int j=i+1;j<n;j++){
            long long sum=arr[i]+arr[j];
            if(mp.find(target - sum)!=mp.end()){
                if(mp[target-sum].first!=i && mp[target-sum].second!=i && mp[target-sum].first!=j && mp[target-sum].second!=j){
                    return "Yes";
                }
            }
            mp[sum]={i,j};
        }
    }
    return "No";
}

----------------------------
#include <bits/stdc++.h>

int lengthOfLongestConsecutiveSequence(vector<int> &arr, int n) {
    // Write your code here.
    int c=0, t=1;
    /*

    unordered_map<int,int>m, vis;
    for(int i=0; i<n; i++){
        m[arr[i]]=1;
    }
    
    for(int i=0; i<n; i++){
        if(vis[arr[i]]){
            continue;
        }
        int z=arr[i];
        while(m[z]){
            vis[z]++;
            t++;
            z++;
        }
        c=max(c, t);
        t=0;
        

    }
    */
    sort(arr.begin(), arr.end());
    int p=arr[0];
    for(int i=1; i<n; i++){
        if(arr[i]-1==p){
t++;
p=arr[i];
        }
        else{
            if(arr[i]==p){
                continue;
            }
            c=max(c, t);
            t=1;
            p=arr[i];
        }
    }
    c=max(c, t);
    return c;
}
--------------------------
#include <bits/stdc++.h>

int LongestSubsetWithZeroSum(vector < int > arr) {

  // Write your code here

  unordered_map<int,int> mp;
  // prefix sum
  int maxi=0;
  vector < int > ar=arr;
  for(int i = 1; i < arr.size(); i++){
      ar[i] += ar[i-1];
      mp[ar[i]]=i;
  }
  for (int i = 0; i < arr.size(); i++) {
  if(mp[ar[i]-arr[i]]>0 and mp[ar[i]-arr[i]]>i){
    maxi=max(maxi, mp[ar[i]-arr[i]]-i+1);
  }
  }
  for (int i = 0; maxi==0 and i < arr.size(); i++) {
    if(arr[i]==0){
      return 1;
    }
  }
  return maxi;
}
---------------------
#include <bits/stdc++.h>

int subarraysXor(vector<int> &arr, int x)
{
    vector<int> ar=arr;
    unordered_map<int,vector<int>>mp;
    mp[ar[0]].push_back(0);
    for(int i=1; i<arr.size(); i++){
ar[i]^=ar[i-1];
mp[ar[i]].push_back(i);
    }
    int a=0;
for(int i=0; i<arr.size(); i++){
    if(mp[ar[i]^arr[i]^x].size()){
        for(auto& q:mp[ar[i]^arr[i]^x]){
            if(q>i){
                a++;
            }
        }
    }
    if(arr[i]==x){
        a++;
    }
}
return a;
}
---------------------------
#include <bits/stdc++.h> 
int uniqueSubstrings(string input)
{
    //Write your code here
    vector<int>v(26, -1);
    int ans=0, l=0, s=0;
    for(int i=0; i<input.size(); i++){
        if(v[input[i]-'a']!=-1){
                 
            l=i-v[input[i]-'a'];
           int t=v[input[i]-'a'];
           
            for(int k=s; k<=t; k++){
                v[input[k]-'a']=-1;
            }
           s=t+1;
        }
        else{
            l++;
            
            
        }
      
        v[input[i]-'a']=i;
        
         ans=max(ans, l);
    }
    
     return ans;
}
-----------------------------
#include <bits/stdc++.h>

/****************************************************************

    Following is the class structure of the LinkedListNode class:

    template <typename T>
    class LinkedListNode
    {
    public:
        T data;
        LinkedListNode<T> *next;
        LinkedListNode(T data)
        {
            this->data = data;
            this->next = NULL;
        }
    };

*****************************************************************/
void rev(LinkedListNode<int> * h,LinkedListNode<int> *p,  LinkedListNode<int> * &hd){
    
    if(!h->next){
         h->next=p;
        hd=h;
   
    return ;
    }
    rev(h->next, h, hd);
     h->next=p;
}
LinkedListNode<int> *reverseLinkedList(LinkedListNode<int> *head) 
{
    // Write your code here
    if(!head){
        return head;
    }
    LinkedListNode<int> * hd=NULL;
    rev(head, NULL, hd);
    return hd;
}
-------------------------------------
/*
Following is the class structure of the Node class:

class Node
{
public:
    int data;
    Node *next;
    Node()
    {
        this->data = 0;
        next = NULL;
    }
    Node(int data)
    {
        this->data = data; 
        this->next = NULL;
    }
    Node(int data, Node* next)
    {
        this->data = data;
        this->next = next;
    }
};
*/

Node *findMiddle(Node *head) {
    // Write your code here
    Node* s=head, *f=head->next;
    while(s and f){
      if (s->next) {
        s = s->next;
      }
      if (f) {
        f = f->next;
        if(f){
            f=f->next;
        }
        
      }
    }
    return s;

}


--------------------------

#include <bits/stdc++.h>

/************************************************************

    Following is the linked list node structure.
    
    template <typename T>
    class Node {
        public:
        T data;
        Node* next;

        Node(T data) {
            next = NULL;
            this->data = data;
        }

        ~Node() {
            if (next != NULL) {
                delete next;
            }
        }
    };

************************************************************/

Node<int>* sortTwoLists(Node<int>* first, Node<int>* second)
{
    // Write your code here.
    Node<int>* f=first, *s=second,  *p=new Node<int>(-1), *h=p;
    while(f and s){
if(f->data<s->data){
    p->next=f;
    p=f;
    f=f->next;
}
else{
    p->next=s;
    p=s;
    s=s->next;
   

}

    }
    if(s){
        p->next=s;
    }
    if(f){
        p->next=f;
    }
    return h->next;
}

-------------------
/*
Following is the class structure of the Node class:

class Node
{
public:
    int data;
    Node *next;
    Node()
    {
        this->data = 0;
        next = NULL;
    }
    Node(int data)
    {
        this->data = data; 
        this->next = NULL;
    }
    Node(int data, Node* next)
    {
        this->data = data;
        this->next = next;
    }
};
*/
Node* rev(Node* a){
    if(!a){
        return a;
    }
    Node* p=NULL;
    Node* c=a;
    Node* n=a->next;
    while(c){
        n=c->next;
        c->next=p;
        p=c;
        c=n;
    }
    return p;
}
Node* removeKthNode(Node* head, int K)
{
    // Write your code here.
    Node* h=rev(head);
    Node* t=h, *p=NULL;
    while(K!=1){
        p=t;
        t=t->next;
        K--;
    }
    if(p){
        p->next=t->next;
    }
    else{
        h=h->next;
    }
    return rev(h);
}

----------------------
/**
 * Definition of linked list:
 *
 * class Node {
 * public:
 *      int data;
 *      Node *next;
 *      Node() {
 *          this->data = 0;
 *          this->next = NULL;
 *      }
 *      Node(int data) {
 *          this->data = data;
 *          this->next = NULL;
 *      }
 *      Node (int data, Node *next) {
 *          this->data = data;
 *          this->next = next;
 *      }
 * };
 *
 *************************************************************************/
Node* rev(Node* a){
    if(!a){
        return a;
    }
    Node* p=NULL;
    Node* c=a;
    Node* n=NULL;
    while(c){
        n=c->next;
        c->next=p;
        p=c;
        c=n;
    }
    return p;
}
Node *addTwoNumbers(Node *num1, Node *num2)
{
    // Write your code here.
    Node* f=num1;
    Node* s=num2;
    
    int sm=0, c=0;
    Node* t=new Node(-1);
    Node* h=t;
    while(f or s){
        if(f){
            sm+=f->data;
            f=f->next;
        }
        if(s){
            sm+=s->data;
            s=s->next;
        }
        sm+=c;
        c=sm/10;
        Node* tt=new Node(sm%10);
        sm=0;
        
        t->next=tt;
        t=tt;
    }
    if(c){
        Node* tt=new Node(c);
        t->next=tt;
        t=tt;
    }
    h=h->next;
    return h;
}

---------------------------------
#include <bits/stdc++.h>

/****************************************************************

    Following is the class structure of the LinkedListNode class:

    template <typename T>
    class LinkedListNode
    {
    public:
        T data;
        LinkedListNode<T> *next;
        LinkedListNode(T data)
        {
            this->data = data;
            this->next = NULL;
        }
    };

*****************************************************************/

void deleteNode(LinkedListNode<int> * node) {
    // Write your code here.
      if(node == NULL){
     
        return;
    }
    if(node->next==NULL){
        node = NULL;
        return;
    }
    node->data = node->next->data;
    LinkedListNode<int> *temp = node->next;
    node->next=node->next->next;
    delete temp;
}
-----------------------------------

/****************************************************************

    Following is the class structure of the Node class:

        class Node
        {
        public:
            int data;
            Node *next;
            Node()
            {
                this->data = 0;
                next = NULL;
            }
            Node(int data)
            {
                this->data = data;
                this->next = NULL;
            }
            Node(int data, Node* next)
            {
                this->data = data;
                this->next = next;
            }
        };

*****************************************************************/
#include<bits/stdc++.h>
Node* findIntersection(Node *f, Node *s)
{
    //Write your code here
   unordered_map<Node* , int>m;
   while(f){
       m[f]++;
       f=f->next;
   }
   while(s){
       m[s]++;
       if(m[s]>1){
           return s;
       }
      s=s->next;
   }
   
}
---------------------------------
/****************************************************************

    Following is the class structure of the Node class:

        class Node
        {
        public:
            int data;
            Node *next;
            Node()
            {
                this->data = 0;
                next = NULL;
            }
            Node(int data)
            {
                this->data = data;
                this->next = NULL;
            }
            Node(int data, Node* next)
            {
                this->data = data;
                this->next = next;
            }
        };


*****************************************************************/
#include<bits/stdc++.h>
bool detectCycle(Node *head)
{
	//	Write your code here
    unordered_map<Node*, bool>b;
    while(head){
        if(b[head]){
            return true;
        }
        b[head]=true;
        head=head->next;

    }
    return false;
}
--------------
#include <bits/stdc++.h>

/****************************************************************

    Following is the class structure of the Node class:

        class Node
        {
        public:
	        int data;
	        Node *next;
	        Node(int data)
	        {
		        this->data = data;
		        this->next = NULL;
	        }
        };

*****************************************************************/
Node* rev(Node* a){
	if(!a){
		return a;
	}
	Node* p=NULL;
	Node* c=a;
	Node* n=NULL;
	while(c){
		n=c->next;
		c->next=p;
		p=c;
		c=n;
	}
	return p;
}
Node* r(Node *head, int n, int b[], int i){
	if(!head){
		return NULL;
	}
	if(i>=n){
		return head;
	}
	Node* t=head;
	if(i<n and b[i]<=0){
		i++;
	}
	int k=0;
	if(i<n){
		k=b[i]-1;
	}
	while(t->next and k>0){
		t=t->next;
		k--;
	}
	Node* nx=t->next;
	t->next=NULL;
	Node* ret=rev(head);
	head->next=r(nx, n, b, i+1);
	return ret;
}

Node *getListAfterReverseOperation(Node *head, int n, int b[]){
	// Write your code here.
	return r(head, n, b, 0);
}
---------------------------
#include <bits/stdc++.h> 
/****************************************************************

    Following is the class structure of the LinkedListNode class:

    template <typename T>
    class LinkedListNode
    {
    public:
        T data;
        LinkedListNode<T> *next;
        LinkedListNode(T data)
        {
            this->data = data;
            this->next = NULL;
        }
    };

*****************************************************************/

bool isPalindrome(LinkedListNode<int> *head) {
    // Write your code here.
   vector<int>v;
    while(head){
        v.push_back(head->data);
        head=head->next;
    }
    int i=0, j=v.size()-1;
    while(i<j){
        if(v[i]!=v[j]){
            return false;
        }
        i++;
        j--;
    }
    return true;

}
------------------------------
/****************************************************************

    Following is the class structure of the Node class:

        class Node
        {
        public:
            int data;
            Node *next;
            Node()
            {
                this->data = 0;
                next = NULL;
            }
            Node(int data)
            {
                this->data = data;
                this->next = NULL;
            }
            Node(int data, Node* next)
            {
                this->data = data;
                this->next = next;
            }
        };


*****************************************************************/
#include<bits/stdc++.h>
Node *firstNode(Node *head)
{
    //    Write your code here.
    unordered_map<Node*, int>m;
    while(head){
        m[head]++;
        if(m[head]>1){
            return head;
        }
        head=head->next;
    }
return NULL;
}
-------------------------------
/*
 * Definition for linked list.
 * class Node {
 *  public:
 *		int data;
 *		Node *next;
 * 		Node *child;
 *		Node() : data(0), next(nullptr), child(nullptr){};
 *		Node(int x) : data(x), next(nullptr), child(nullptr) {}
 *		Node(int x, Node *next, Node *child) : data(x), next(next), child(child) {}
 * };
 */
#include<bits/stdc++.h>
Node* flattenLinkedList(Node* head) 
{
	// Write your code here
	vector<int>v;
	while(head){
		Node* c=head;
		while(c){
			v.push_back(c->data);
			c=c->child;
		}
		Node* t=head->next;
		head->next=NULL;
		head=t;
	}
	sort(v.begin(), v.end());

	Node* n=new Node(-1), *h=n;
	for(int i=0; i<v.size(); i++){
		Node* nn=new Node(v[i]);
		n->child=nn;
		n=nn;
	}
	return h->child;
}

----------------------------------
/**
 * Definition for singly-linked list.
 * class Node {
 * public:
 *     int data;
 *     Node *next;
 *     Node() : data(0), next(nullptr) {}
 *     Node(int x) : data(x), next(nullptr) {}
 *     Node(int x, Node *next) : data(x), next(next) {}
 * };
 */
Node* rev(Node* h){
     if(!h){
          return h;
     }
     Node* p=NULL, *c=h, *n=NULL;
     while(c){
          n=c->next;
          c->next=p;
          p=c;
          c=n;
     }
     return p;
}
Node *rotate(Node *head, int k) {
     // Write your code here.
     if(k==0){
          return head;
     }
     Node* qw=head;
     int ct=0;
     while(qw){
          ct++;
          qw=qw->next;
     }
     if(k>ct){
          k=k%ct;
          
     }
     if(k==ct or k==0){
          return head;
     }
     Node* h=rev(head), *hh=h;
     int i=1;
     while(i<k){
          hh=hh->next;
          i++;
     }
     
     
     Node* t=hh->next;
     hh->next=NULL;
     Node* tp=t;
     while(tp->next){
          tp=tp->next;
     }
  
       tp->next = h;
       return rev(t);
    
}
--------------------------
#include <bits/stdc++.h>

/*************************************************************

    Following is the LinkedListNode class structure

    template <typename T>   
    class LinkedListNode
    {
        public:
        T data;
        LinkedListNode<T> *next;
        LinkedListNode<T> *random;
        LinkedListNode(T data)
        {
            this->data = data;
            this->next = NULL;
        }
    };

*************************************************************/

LinkedListNode<int> *cloneRandomList(LinkedListNode<int> *head)
{
    // Write your code here.
    LinkedListNode<int> * h=new LinkedListNode<int> (-1), *q=head, *hd=h;
    unordered_map<LinkedListNode<int> *, LinkedListNode<int> *>m;
    while(q){
        LinkedListNode<int> * n=new LinkedListNode<int> (q->data);
        m[q]=n;
        q=q->next;
        
        h->next=n;
        h=n;
    }
    q=head;
    while(q){
        m[q]->random=m[q->random];
        q=q->next;
    }
return hd->next;

}

----------------------------------------

 

#include <bits/stdc++.h> 

vector<vector<int>> findTriplets(vector<int>arr, int n, int K) {

    // Write your code here.

    vector<vector<int>>ans;

    sort(arr.begin(),arr.end());

    for(int i=0;i<n;i++){

        int left=i+1;

        int right=n-1;

        int target=K-arr[i];

 

        while(left<right){

            

            int sum=arr[left]+arr[right];

            if(sum>target){

                 right--;

            }

            else if(sum<target){

                left++;

            }

            else{

                ans.push_back({arr[i],arr[left],arr[right]});

                int x=arr[left];

                int y=arr[right];

                

                

                while(left<right && arr[left]==x){

                    left++;

                }

                while(left<right && arr[right]==y){

                    right--;

                }

        

            }

        }

        while(i+1<n && arr[i]==arr[i+1]){

            i++;

        }

    }

    return ans;

}
-----------------------------------------
#include <bits/stdc++.h> 
long getTrappedWater(long *arr, int n){
    // Write your code here.
    vector<long>l(n, -1), r(n, -1);
    long mx=-1;
    for(int i=0; i<n; i++){
        l[i]=mx;
        if(*(arr+i)>mx){
            mx=*(arr+i);
        }
    }
    mx=-1;
    for(int i=n-1; i>=0; i--){
        r[i]=mx;
        if(*(arr+i)>mx){
            mx=*(arr+i);
        }
    }
    long ans=0;
    for(int i=0; i<n; i++){
        
            long t=(min(l[i], r[i])-*(arr+i));
            if(t>0 and l[i]!=-1 and r[i]!=-1){
                ans+=t;
            }
        
    }
    return ans;
}
--------------------------------
#include<bits/stdc++.h>
int removeDuplicates(vector<int> &arr, int n) {
	// Write your code here.
	sort(arr.begin(), arr.end());
	int mx=-1;
	int c=0;
	for(int i=0; i<n; i++){
		if(mx==-1){
			mx=arr[i];
			c++;
		}
		else if(arr[i]!=mx){
			mx=arr[i];
			c++;
		}
	}
	return c;
}
---------------------------
#include<bits/stdc++.h>
int max(int a, int b){
    return a>b?a:b;
}
int longestSubSeg(vector<int> &arr , int n, int k){
    // Write your code here.
    int maxi=0;
    queue<int>q;
    for(int i=0; i<n; i++){
        if(arr[i]){
            q.push(1);
        }
        else{
            if(k>0){
                 q.push(0);
                 --k;
            }
            else{
                while(q.front()!=0){
                    q.pop();
                }
                q.pop();
                q.push(0);
            }
            
        }
        maxi=max(maxi, q.size());
    }
    return maxi;
}

--------------------------
#include <bits/stdc++.h> 

vector<int> maximumMeetings(vector<int> &start, vector<int> &end) {
    vector<int>ans;
    vector<vector<int>>v(start.size());
    for(int i=0;i<v.size();i++) {
        v[i]={end[i],i+1,start[i]};
    }
    sort(v.begin(),v.end());
    int finish=v[0][0];
    ans.push_back(v[0][1]);
    for(int i=1;i<v.size();i++) {
        if(v[i][2]>finish) {
            finish=v[i][0];
            ans.push_back(v[i][1]);
        }
    }
    return ans;
}
----------------------------------
int calculateMinPatforms(int at[], int dt[], int n) {

    // Write your code here.

    sort(at, at+n);

    sort(dt, dt+n);

 

    int pltCount = 1, i=1, j=0;

    int minPlatforms = 1;

    while (i < n && j < n) {

        if (at[i] <= dt[j]) {

            pltCount++;

            i++;

            if (pltCount > minPlatforms) {

                minPlatforms = pltCount;

            }

        } else {

            pltCount--;

            j++;

        }

    }

 

    return minPlatforms;

}
--------------------------
#include <bits/stdc++.h> 
int jobScheduling(vector<vector<int>> &jobs)
{
    // Write your code here
    priority_queue<int>p;
    unordered_map<int,  vector<int>>mp;
    int mx=0;
    for(int i=0; i<jobs.size(); i++){
        mx=max(mx, jobs[i][0]);
        mp[jobs[i][0]].push_back(jobs[i][1]);
    }
    int ans=0;
    for(int i=mx; i>0; i--){
        
        
          for (auto &q : mp[i]) {
            p.push(q);
          }
          if(p.size()==0){
              continue;
          }
          ans += p.top();
          p.pop();
        
    }
    return ans;

}

-------------------------------
#include <bits/stdc++.h> 
 bool cmp(pair<double,int>a, pair<double,int>b){
    return a.first>b.first;
}
double maximumValue (vector<pair<int, int>>& items, int n, int w)
{
    // Write your code here.
    // ITEMS contains {weight, value} pairs.
    vector<pair<double,int>>r;
    for (int i = 0; i < n; i++) {
        double d=((double)items[i].second/(double)items[i].first);
        r.push_back({d, i});

    }
    
    sort(r.begin(), r.end(), cmp);
    double tot=0;
    int i=0;
   
    while(w>0){
        if(i==n){
            break;
        }
        if(items[r[i].second].first<w){
            tot+=items[r[i].second].second;
          //  cout<<items[r[i].second].second<<endl;
            w-=items[r[i].second].first;



            i++;
        }
        else{
            tot+=((double)items[r[i].second].second/(double)items[r[i].second].first)*((double)w);
            break;
        }
      
    }
    return tot;

}
---------------------------------
#include <bits/stdc++.h> 
int findMinimumCoins(int amount) 
{
    // Write your code here
    int cnt=0;
    while(amount){
        if(amount>=1000){
            cnt+=amount/1000;
            amount=amount%1000;
        }
        if(amount>=500){
            cnt+=amount/500;
            amount=amount%500;
        }
        if(amount>=100){
            cnt+=amount/100;
            amount=amount%100;
        }
        if(amount>=50){
            cnt+=amount/50;
            amount=amount%50;
        }
        if(amount>=20){
            cnt+=amount/20;
            amount=amount%20;
        }
        if(amount>=10){
            cnt+=amount/10;
            amount=amount%10;
        }
        if(amount>=5){
            cnt+=amount/5;
            amount=amount%5;
        }
        if(amount>=2){
            cnt+=amount/2;
            amount=amount%2;
        }
        if(amount>=1){
            cnt+=amount/1;
            amount=amount%1;
        }
        
    }
    return cnt;
}

--------------------------------
#include<bits/stdc++.h>
static bool cmp(pair<int,int>a, pair<int,int>b){
    return a.second<b.second;
}
int maximumActivities(vector<int> &start, vector<int> &finish) {
    // Write your code here.
    vector<pair<int,int>>v;
    for(int i=0; i<start.size(); i++){
        v.push_back({start[i], finish[i]});

    }
    sort(v.begin(), v.end(), cmp);
    int c=1;
    int x=v[0].second;
    for(int i=1; i<v.size(); i++){
        if(v[i].first>=x){
            c++;
            x=v[i].second;
        }
    }
    return c;
}
--------------------------------
#include <bits/stdc++.h> 
vector<int> subsetSum(vector<int> &num)
{
    // Write your code here.
    vector<int>v;
    for(int i=0; i<pow(2, num.size()); i++){
        int j=0;
        int cnt=0;
        int t=i;
        while(t){
            if(t&1){
                cnt+=num[j];
            }
            j++;
            t>>=1;
        }
            v.push_back(cnt);

    }
    sort(v.begin(), v.end());
    return v;
}
---------------------
#include <bits/stdc++.h> 
vector<vector<int>> uniqueSubsets(int n, vector<int> &num)
{
     vector<vector<int>>v;
     map<vector<int>, int>mp;
    for(int i=0; i<pow(2,n); i++){
        int j=0;
       
        int t=i;
        vector<int> tt;
        while(t){
            if(t&1){
               tt.push_back(num[j]);
            }
            j++;
            t>>=1;
        }

        sort(tt.begin(), tt.end());
        if (mp[tt] == 0) {
          v.push_back(tt);
          mp[tt]=1;
        }
    }
    sort(v.begin(), v.end());
    return v;
}
----------------------------------



vector<vector<int>> findSubsetsThatSumToK(vector<int> arr, int n, int k)
{
    // Write your code here.
    vector<vector<int>>v;
    for(int i=0; i<pow(2, n); i++){
        int t=i;
        int c=0;
        int j=0;
        vector<int>tm;
        while(t){
            if(t&1){
                c+=arr[j];
    tm.push_back(arr[j]);
            }
            t>>=1;
            j++;
        }
        if(c==k){
           // sort(tm.begin(), tm.end());
            v.push_back(tm);
        }
    }
    sort(v.begin(), v.end());
    return v;

}
-----------------------
#include<set>

#include<algorithm>

void solve(vector<int>& candidates,int target,set<vector<int>>&ans,vector<int>&v,int index)

{
	if(target==0)

{
vector<int>t=v;
sort(t.begin(),t.end());

ans.insert(t);

}
if(index==candidates.size())

{


return;

}

if (target-candidates[index]>=0) {
  v.push_back(candidates[index]);

  solve(candidates, target - candidates[index], ans, v, index + 1);

  v.pop_back();
}

while(index+1<candidates.size() && candidates[index]==candidates[index+1]) index++;
    
solve(candidates,target,ans,v,index+1);


 

 

}

vector<vector<int>> combinationSum2(vector<int> &arr, int n, int target)

{

set<vector<int>>ans;
sort(arr.begin(), arr.end());
vector<int>v;

int index=0;

solve(arr,target,ans,v,index);

vector<vector<int>> answer;

for(auto& it:ans)

{

answer.push_back(it);

}

return answer;

 

}


-------------------------------
#include <bits/stdc++.h> 

bool isSafe(string &s, int start , int end){

    while (start <= end){
        if(s[start++] != s[end--]){
            return false;
        }
    }
    return true;
}

void solve(int index , string &s, vector<string> &curr , vector<vector<string>> &res){

    //Base Case
    if(index == s.size()){
        res.push_back(curr);
        return;
    }

    for(int i = index; i < s.size(); i++){
        if(isSafe(s, index ,i)){
            curr.push_back(s.substr(index , i - index + 1));
            solve(i+1, s, curr, res);
            curr.pop_back();
        }
    }

}

vector<vector<string>> partition(string &s) 
{
    // Write your code here.
    vector<vector<string>> res;
    vector<string> curr;

    solve(0 , s , curr , res);

    return res;
}
--------------------------
#include<bits/stdc++.h>
string kthPermutation(int n, int k) {
    // Write your code here.
       
    vector<int> numbers;
    int fact=1;
    for(int i = 1; i < n; i++){
        fact = fact * i;
        numbers.push_back(i);
    }
    numbers.push_back(n);
    // for 0 base indexing
    k = k-1;
    string ans = "";
    while(true){
        ans += to_string(numbers[k/fact]);
        // erasing the picked number
        numbers.erase(numbers.begin() + k/fact);

        if(numbers.size() == 0){
            break;
        }

        // re calculating k
        k = k % fact;
        fact = fact / numbers.size();
    }

    return ans;
    
}

-----------------------------------------------
#include <bits/stdc++.h> 
void ss(string &s, vector<string>&res, string& p, vector<int>&v){
    if(p.size()==s.size()){
        res.push_back(p);
        return ;
    }
    for(int i=0; i<s.size(); i++){
        if(v[i]){
            continue;
        }
        p.push_back(s[i]);
        v[i]=1;
        ss(s, res, p, v);
        v[i]=0;
        p.pop_back();
        
    }

}
vector<string> findPermutations(string &s) {
    // Write your code here.
vector<string>res;
vector<int>v(s.size(), 0);
string p;
ss(s, res, p, v);
return res;
}
------------------------------------
#include<bits/stdc++.h>
void s(int& n, int i, unordered_map<int,int>&rd, unordered_map<int,int>&ld, unordered_map<int,int>&c, vector<int>&v, vector<vector<int>>&res){
    if(i==n){
        res.push_back(v);
        return ;
    }
    for(int j=0; j<n; j++){
        if(rd[i+j]==0 and ld[i-j]==0 and c[j]==0){
            rd[i+j]=1;
            ld[i-j]=1;
            c[j]=1;
            v[(n*i)+j]=1;
           s(n, i+1, rd, ld, c, v, res);
        
            v[(n*i)+j]=0;
            rd[i+j]=0;
            ld[i-j]=0;
            c[j]=0;
           
        }
    }
    return ;

}
vector<vector<int>> solveNQueens(int n) {
    unordered_map<int,int> rd, ld, c;
    vector<int>v(n*n, 0);
    vector<vector<int>>res;
    s(n, 0, rd, ld, c, v, res);
    return res;
}
-------------------------------------------
#include<bits/stdc++.h>
bool safe(int matrix[9][9], int i, int j, int k){
int r=(i/3)*3;
int c=(j/3)*3;
for(int s=r; s<r+3; s++){
    for(int e=c; e<c+3; e++){
        if(matrix[s][e]==k){
            return false;
        }
    }
}
return true;
}
bool s(int matrix[9][9], int i, int j, vector<vector<int>>&r, vector<vector<int>>&c){
if(j==9){
   return s(matrix, i+1, 0, r, c);
}
if(i==9){
    return true;
}
if(matrix[i][j]==0){
    for(int k=1; k<=9; k++){
        if(r[i][k]==0 and c[j][k]==0 and safe(matrix, i, j, k)){
                matrix[i][j]=k;
                r[i][k]=k;
                c[j][k]=k;
            if(s(matrix, i, j+1, r, c)){
                return true;
            }
            matrix[i][j]=0;
            r[i][k]=0;
            c[j][k]=0;
        }
    }
}
else{
    return s(matrix, i, j+1, r, c);
}
return false;

}
bool isItSudoku(int matrix[9][9]) {
    // Write your code here.
    vector<vector<int>>r(9, vector<int>(10, 0));
    vector<vector<int>>c(9, vector<int>(10, 0));
    //vector<vector<int>>mat(9, vector<int>(9, 0));

for(int i=0; i<9; i++){
        for(int j=0; j<9; j++){
          //  mat[i][j]=matrix[i][j];
            r[i][matrix[i][j]]=1;
            c[j][matrix[i][j]]=1;
        }
        
    }
    bool a= s(matrix, 0, 0, r, c);
   
return a;
}

--------------------------------------------
bool canColor (vector<vector<int>> &mat,vector<int>&paint , int n  , int color , int m , int node  ){
    
    //check if all relatives are not of color (color)
   
    for ( int i=0; i<n; i++){
        if(i!=node  and mat[node][i]==1 and paint[i]==color)return false;
    }
    //no error 
    return true;
    
} 

 bool recur(vector<vector<int>> &mat, vector<int>& paint , int n , int m, int start){
     
     // when to break;
     if(start==n)return true;
     
     //try this node with  any possible color 
     
     for( int i=1; i<=m ; i++){
         //if possible to color 
         if( canColor( mat,paint ,n,i, m,start)){
             //paint that sh*t
             paint[start]=i;
             //check if others accept that rhythm
             if(recur ( mat, paint , n , m , start+1))return true;
             //else you painted the wrong bro, leave that unpaint
             paint[start]=0;
         }
         
       
        
     } 
       // no true return  in any color combination with any node :)
      return false;
 }
string graphColoring(vector<vector<int>> &mat, int m) {

    int n = mat.size();
    int start=0;
    vector<int>paint(n,0);
    if(recur(mat,paint , n,m , start))return "YES";
    return "NO";
   
}




----------------------------------------
#include <bits/stdc++.h> 
void sol(vector<vector<int> > &maze, vector<vector<int> > &v, int i, int j, int&n, vector<vector<int> >&res){
  if(i==n-1 and j==n-1){
   vector<int>t;
   v[i][j]=1;
   for(auto& q: v){
     t.insert(t.end(), q.begin(), q.end());
   }
   res.push_back(t);
   v[i][j]=0;
   return;
  }
  if(i==n or j==n){
    return;
  }
  v[i][j]=1;
  if(i-1>=0 and v[i-1][j]==0 and maze[i-1][j]){
    sol(maze, v, i-1, j, n, res);
  }
  if(i+1<n and v[i+1][j]==0 and maze[i+1][j]){
    sol(maze, v, i+1, j, n, res);
  }
  if(j-1>=0 and v[i][j-1]==0 and maze[i][j-1]){
    sol(maze, v, i, j-1, n, res);
  }
  if(j+1<n and v[i][j+1]==0 and maze[i][j+1]){
    sol(maze, v, i, j+1, n, res);

  }
  v[i][j]=0;
}
vector<vector<int> > ratInAMaze(vector<vector<int> > &maze, int n){
  vector<vector<int> >v(n, vector<int>(n, 0));
  vector<vector<int> >res;
   
  sol(maze, v, 0, 0, n, res);
  return res;
}
----------------------------------------
#include <bits/stdc++.h> 
class Trie{
    public:
    char data;
    bool term;
    Trie* child[26];
    Trie(char d){
        this->data=d;
        for(int i=0; i<26; i++){
            this->child[i]=NULL;
        }
        this->term=false;
    }

};
class T{
    public:
    Trie* t=NULL;
    
    T(){
        this->t=new Trie('-');
        
    }
    pair<bool,bool> fnd(string s, Trie* t){
         if(s.size()==0 ){
          
        if(t->term){
            return {true, true};
        }
        else  if(!t->term){
          return {true, false};
        }
            
        }
        if(t->child[s[0]-'a']){
            return fnd(s.substr(1), t->child[s[0]-'a']);
        }
        else{
          return {false, false};
        }

    }
    pair<bool,bool> f(string s){
       return  fnd(s, this->t);
    }
    void pt(string s, Trie* t){
        if(s.size()==0){
            t->term=true;
            return;
        }
        if(t->child[s[0]-'a']){
            pt(s.substr(1), t->child[s[0]-'a']);
        }
        else{
            Trie* n=new Trie(s[0]);
            t->child[s[0]-'a']=n;
            
            pt(s.substr(1), t->child[s[0]-'a']);


        }
    }
    void ins(string s){
        pt(s, this->t);
    }
};
void sol(T& n, string &s, string &t, int i, vector<string>&x){
    if(i>=s.size()){
        x.push_back(t);
        return;
    }
    string tp;
    for(int j=i; j<s.size(); j++){
        tp.push_back(s[j]);
        auto qp=n.f(tp);
        string z=t;
        if(qp.first){
            if(qp.second){
                z+=tp;
                z+=" ";
                sol(n, s, z, j+1, x);
            }
        }
        else{
            return;
        }
       
    }
}
vector<string> wordBreak(string &s, vector<string> &d)
{
    // Write your code here
    T n;
    for(auto& q: d){
        n.ins(q);
    }
    vector<string>x;
    string t;
   sol(n, s, t, 0, x);
    return x;


}
------------------------------------
#include<bits/stdc++.h>
int po(int a, int b){
  int res=1;
  while(b){
    if (b & 1) {
      res *= a;
    }
    a *= a;
    b /= 2;
  }
  return res;
}
int NthRoot(int n, int m) {
  // Write your code here.
 for(int i=1; pow(i, n)<=m; i++){
   if(po(i, n)==m){
     return i;
   }
 }
 return -1;
}
-----------------------
#include<algorithm>
int getMedian(vector<vector<int>> &matrix)
{
    // Write your code here.
    vector<int>v;
    for(auto& q: matrix){
        v.insert(v.end(), q.begin(), q.end());

    }
    sort(v.begin(), v.end());
    return v[((matrix.size()*matrix[0].size())/2)];
}
-------------------------
bool check(int k, vector<int>&nums){

if(k%2==0){

if(k==0||nums[k]!=nums[k-1]) return true;

}

else{

if(nums[k]==nums[k-1]) return true;

}

return false;

}

 

int singleNonDuplicate(vector<int>& arr)

{

// Write your code here

int lo=0,n=arr.size(),ans=-1,hi;

hi=n;

while(lo<=hi){

int mid=lo+(hi-lo)/2;

if(check(mid,arr)){

ans=arr[mid];

lo=mid+1;

}

else hi=mid-1;

}

return ans;

}


-------------------------
#include<bits/stdc++.h>
int bs(int key, int* arr, int i, int j){
    
   while(i<=j){
       int m=i+(j-i)/2;
       if(*(arr+m)==key){
           return m;
       }
       else if(*(arr+m)>key){
           j=m-1;
       }
       else{
           i=m+1;
       }
   }
   return -1;
}
int b(int n, int* arr){
    int i=0, j=n-1;
    int ans=-1;
    while(i<=j){
        int m=i+(j-i)/2;

        if(*(arr+m)>*(arr+n-1)){
            i=m+1;
            
        }
        else{
            j=m-1;
        }
    }
    return ans=i-1;
}
int search(int* arr, int n, int key) {
    // Write your code here.
    int p=b(n, arr);
 if(key>*(arr+n-1)){
     return bs(key, arr, 0, p);
 }
 else{
     return bs(key, arr, p+1, n-1);
 }

   // cout<<*arr<<endl;
   
}
--------------------------
double median(vector<int>& a, vector<int>& b) {

    if(a.size() > b.size()) median(b, a);

    int n1 = a.size();

    int n2 = b.size();

    int l = 0, r = n1;

    while(l <= r){

        int m1 = l + (r - l) / 2;

        int m2 = (n1 + n2 + 1) / 2 - m1;

        int l1 = m1 == 0 ? INT_MIN : a[m1 - 1];

        int l2 = m2 == 0 ? INT_MIN : b[m2 - 1];

        int r1 = m1 == n1 ? INT_MAX : a[m1];

        int r2 = m2 == n2 ? INT_MAX : b[m2]; 

        if(l1 <= r2 and l2 <= r1){

            if((n1 + n2) % 2 == 0){

                return ((max(l1, l2)) + (min(r1, r2))) / 2.0;

            }else{

                return max(l1, l2);

            }

        }else if(l1 > r2){

            r = m1 - 1; 

        }else{

            l = m1 + 1;

        }

    }

}
---------------------------

int ninjaAndLadoos(vector<int> &row1, vector<int> &row2, int m, int n, int k) 
{     
    // If length of first array is smaller then length of second then swap both the arrays.    
    if (m > n) 
    {
        return ninjaAndLadoos(row2, row1, n, m, k);
    }
  
    if (m == 0) 
    {
        return row2[k - 1];
    }
    
    // If k is equal to 1
    if (k == 1) 
    {
        return min(row1[0], row2[0]);
    }
  
    int i = min(m, k / 2);
    int j = min(n, k / 2);
    
    // If row1[i - 1] is greater than row2[j - 1]
    if (row1[i - 1] > row2[j - 1]) 
    {
        vector<int> newRow2;
        newRow2.assign(row2.begin() + j, row2.end());
        
        return ninjaAndLadoos(row1, newRow2, m, n - j, k - j);
    } 

    vector<int> newRow1;
    newRow1.assign(row1.begin() + i, row1.end());
        
    return ninjaAndLadoos(newRow1, row2, m - i, n, k - i);  
} 
-------------------------
#include <bits/stdc++.h> 
bool pos(long long m, vector<int>& v, long long& mx){
long long i=0, tot=0;

while(m and i<v.size()){
if(v[i]>mx){
	return false;
}
else{
  if (tot + v[i] <= mx) {
    tot += v[i];
  }
  else{
	  m--;
	  tot=v[i];
  }
  
}
i++;
}
if(m<1 or i<v.size()){
	return false;
}
return true;
}
long long ayushGivesNinjatest(int n, int mm, vector<int>& time) 
{	
	long long t=0;
	for(int i=0; i<time.size(); i++){
		t+=time[i];
	}
	
	long long s=0, ans=0;
	while(s<=t){
		long long m=(t+s)/2;
		if(pos(n, time, m)){
			
			ans=m;
			t=m-1;
		}
		else{
			s=m+1;
		}
	}
	return ans;
}
-------------------------------------
#include <bits/stdc++.h>
bool canAssign(int c, int mid, vector<int> &positions) {
  int allot = 1, player = positions[0];
  for (int i = 1; i < positions.size(); i++) {
    if (positions[i] - player >= mid) {
      allot++;
      player = positions[i];
    }

    if (allot == c)
      return true;
  }

  return false;
}

int chessTournament(vector<int> &positions, int n, int c) {
  sort(positions.begin(), positions.end());
  int low = 1, high = positions[n - 1] - positions[0];
  int ans = -1;

  while (low <= high) {
    int mid = low + (high - low) / 2;
    if (canAssign(c, mid, positions)) { // minimum distance
      ans = mid;
      low = mid + 1;
    } else
      high = mid - 1;
  }
  return ans;
}
--------------------------
#include <bits/stdc++.h>
void put( vector<int>&r, int t, int& st ){
    if(r.size()-st==0){
        r.push_back(t);
        return;
    }
    int s=st, e=r.size()-1, ans=-1;
    while(s<=e){
        int m=s+(e-s)/2;
        if(r[m]<t){
            ans=m;
            s=m+1;
        }
        else{
            e=m-1;
        }
    }

   
    if(ans==-1 and st==0){
         r.push_back(0);
      for (int i = r.size() - 1; i > 0; i--) {
        r[i] = r[i - 1];
      }
      r[st]=t;
    return;
    } else if (ans == -1) {
      st--;
      r[st]=t;
    return;
    }
    
     r.push_back(0);
    for(int i=r.size()-1; i>ans+1; i--){
        r[i]=r[i-1];
    }
    r[ans+1]=t;
} 
vector<int> minHeap(int n, vector<vector<int>>& q) {
    // Write your code here.
    vector<int>r, ret;
    int s=0;
    for (int i = 0; i < n; i++) {
      if(q[i].size()>1){
          put(r, q[i][1], s);
      }
      else{
           
          ret.push_back(r[s]);
          s++;
      }
    }
    return ret;
}

-----------------------------
vector<int> kthSmallLarge(vector<int> &arr, int n, int k)
{
	// Write your code here.
	priority_queue<int>mx;
	priority_queue<int, vector<int>, grester<in>>mn;
	int i=k, j=0;
	while(i--){
		mx.push(arr[j]);
		mn.push(arr[j]);
		j++;
	}
	while(j<arr.size()){
		if(arr[j]<mx.top()){
			mx.pop();
			mx.push(arr[j]);

		}
		j++;
	}
	j=k;
	while(j<arr.size()){
		if(arr[j]>mn.top()){
			mn.pop();
			mn.push(arr[j]);

		}
		j++;
	}
vector<int>res(2);
res[0]=mx.top();
res[1]=mn.top();
return res;
}

-------------------------------------------
#include <bits/stdc++.h> 
vector<int> kMaxSumCombination(vector<int> &a, vector<int> &b, int n, int k){

    // Write your code here.

    priority_queue<int> pq;

    for(int i=0;i<n;i++){

        for(int j=0;j<n;j++){

            pq.push(a[i] + b[j]);

        }

    }

    vector<int> ans;

    for(int i=0;i<k;i++){

        int f = pq.top();

        pq.pop();

        ans.push_back(f);

    }

    return ans;

}
--------------------------------------
#include <bits/stdc++.h>
void findMedian(int *arr, int n)
{
    // Write your code here
    priority_queue<int>maxh;
    priority_queue<int,vector<int>,greater<int>>minh;

    for(int i=0;i<n;i++){
        if(maxh.empty() || maxh.top()>=arr[i]) maxh.push(arr[i]);
        else minh.push(arr[i]);

        if(maxh.size()>minh.size()+1){
            minh.push(maxh.top());
            maxh.pop();
        }
        else if(maxh.size()<minh.size()){
            maxh.push(minh.top());
            minh.pop();
        }

        if(minh.size()<maxh.size()) cout<<maxh.top()<<" ";
        else cout<<(minh.top()+maxh.top())/2<<" ";
    }

}
----------------------
#include <bits/stdc++.h> 
vector<int> mergeKSortedArrays(vector<vector<int>>&k, int t)
{
    vector<int>v;
    for(auto& q: k){
        v.insert(v.end(), q.begin(), q.end());
    }
sort(v.begin(), v.end());
return v;
}

-------------------------------------
#include <bits/stdc++.h> 
bool cmp(pair<int,int>a, pair<int,int>b){
    return a.second>b.second;
}
vector<int> KMostFrequent(int n, int k, vector<int> &arr)
{
    unordered_map<int,int>m;
   for(auto& q: arr){
       m[q]++;
   }
   vector<pair<int,int>>v;
    for(auto& q: m){
        v.push_back(q);
    }
    sort(v.begin(), v.end(), cmp);
    vector<int>r;
    for(auto& q: v){
        r.push_back(q.first);
        k--;
        if(!k){
            break;
        }
    }
    sort(r.begin(), r.end());
    return r;

}
--------------------------------

/*
    Your Trie object will be instantiated and called as such:
    Trie* obj = new Trie();
    obj->insert(word);
    bool check2 = obj->search(word);
    bool check3 = obj->startsWith(prefix);
 */

class T{
public: 
char d;
T* ch[26];
bool term;
T(char data){
    this->d=data;
    for(int i=0; i<26; i++){
        ch[i]=NULL;
    }
    this->term=false;
}
};
class Trie {

public:

    /** Initialize your data structure here. */
   T* t=NULL;
    Trie() {
         this->t=new T('/');
    }
    void ins(string w, T* p){
        if(w.size()==0){
            p->term=true;
            return;
        }
        if(p->ch[w[0]-'a']){
            ins(w.substr(1), p->ch[w[0]-'a']);
        }
        else{
            T* n=new T(w[0]);
            p->ch[w[0]-'a']=n;
            ins(w.substr(1), p->ch[w[0]-'a']);

        }
    }
    /** Inserts a word into the trie. */
    void insert(string w) {
       return ins(w, this->t);
    }

    /** Returns if the word is in the trie. */
    bool src(string w, T* p){
        if(w.size()==0 ){
          if (p->term) {
            return true;
          }
          return false;
        }
        if(p->ch[w[0]-'a']){
          return  src(w.substr(1), p->ch[w[0]-'a']);
        }
        else{
            return false;
        }
    }
    bool search(string w) {
       return src(w, this->t);
    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool sw(string w, T* p){
        if(w.size()==0){
         
            return true;
          
        }
        if(p->ch[w[0]-'a']){
          return  sw(w.substr(1), p->ch[w[0]-'a']);
        }
        else{
            return false;
        }
    }
    bool startsWith(string pre) {
        return sw(pre, this->t);
    }
};
------------------------

#include <bits/stdc++.h> 
class T{
public: 
char d;
T* ch[26];
bool term;
int cnt;
T(char data){
    this->d=data;
    for(int i=0; i<26; i++){
        ch[i]=NULL;
    }
    this->term=false;
    this->cnt=0;
}
};
class Trie{

    public:
 T* t=NULL;
    Trie(){
        // Write your code here.
          this->t=new T('/');
    }
void ins(string w, T* p){
    p->cnt++;
        if(w.size()==0){
            p->term=true;
            return;
        }
        if(p->ch[w[0]-'a']){
            ins(w.substr(1), p->ch[w[0]-'a']);
        }
        else{
            T* n=new T(w[0]);
            p->ch[w[0]-'a']=n;
            ins(w.substr(1), p->ch[w[0]-'a']);

        }
    }
    void insert(string &w){
        // Write your code here.
          ins(w, this->t);
         
    }
    int ret(string w, T* p){
        if(p==NULL){
            return 0;
        }
        if(w.size()==0 ){
         
          return p->cnt;
        }
       
          return  ret(w.substr(1), p->ch[w[0]-'a']);
        
        
    }
    int r(string w, T* p){
         if(p==NULL){
            return 0;
        }
        if(w.size()==0 ){
          int tot=0;
          for(int i=0; i<26; i++){
            if (p->ch[i]) {
              tot += p->ch[i]->cnt;
            }
          }
          return p->cnt-tot;
        }
       
          return  r(w.substr(1), p->ch[w[0]-'a']);
        
        
    }
    int countWordsEqualTo(string &w){
        // Write your code here.
        return r(w, this->t);
       
    }

    int countWordsStartingWith(string &w){
        // Write your code here.
         return ret(w, this->t);
    }
void i(string w, T* p){
   
        if(w.size()==0){
           p->cnt--;
            if(p->cnt==0){
                p=NULL;
                
            }
            return;
        }
       
            i(w.substr(1), p->ch[w[0]-'a']);
         p->cnt--;
            if(p->cnt==0){
                p=NULL;
                return;
            }
        
    }
    void erase(string &w){
        // Write your code here.
        return i(w, this->t);
    }
};

------------------------------------
#include <bits/stdc++.h>
class T{
    public:
char d;
T* ch[26];
int c;
bool term;
T(char data){
    this->d=data;
    for(int i=0; i<26; i++){
        this->ch[i]=NULL;
    }
    this->c=0;
    this->term=false;
}
};
class Trie{
    public:
    T* t=NULL;
Trie(){
t=new T('-');
}
string ss(T* p){
    
        int u=0;
         string zz=""; 
        for(int i=0; i<26; i++){
                if(p->ch[i] and p->ch[i]->term){
                   string k;
                   k=ss(p->ch[i]);
                   if(k.size()>zz.size()){
                       zz=k;
                   }
                }
        }
        string z="";
        z+=p->d;
       
         return  z+zz;
   
    
    
}
string src(){
return ss(this->t);
}

void i(string s, T* p){
    if(s.size()==0){
        p->term=true;
        
        return;
    }
    if(p->ch[s[0]-'a']){
        i(s.substr(1), p->ch[s[0]-'a']);
    }
    else{
        p->c++;
        T* n=new T(s[0]);
        p->ch[s[0]-'a']=n;
        i(s.substr(1), p->ch[s[0]-'a']);
    }
}

void ins(string s){
i(s, this->t);

}

};
string completeString(int n, vector<string> &a){
    // Write your code here.
    Trie* t=new Trie();
    for(auto& q: a){
        t->ins(q);
    }
    string z=t->src();
   if(z=="-"){
       return "None";
   }
    return z.substr(1);
  
}
-------------------------------------
#include <bits/stdc++.h> 
int distinctSubstring(string &word) {
    //  Write your code here.
        set<string> st;
    
    int l = word.length();
    
    for(int i=0; i<l; ++i){
        for(int j=1; j<=l; ++j){
            string t = word.substr(i,j);
            st.insert(t);
        }
    }
    
    return st.size();
}

------------------------------------------
#include <bits/stdc++.h> 
vector<vector<int>> pwset(vector<int>v)
{
    //Write your code here
    int n=v.size();
    sort(v.begin(), v.end());
    vector<vector<int>>r;
    for(int i=0; i<pow(2,n); i++){
        int t=i, j=0;
        vector<int>vv;
        while(t){
            
            if(t&1){
                    vv.push_back(v[j]);
            }
            j++;
            t>>=1;

        }
        
        r.push_back(vv);
    }
    sort(r.begin(), r.end());
    return r;
}
------------------------------
#include <bits/stdc++.h> 


class Node{
    public:
    int data;
    Node*child[2];
    Node(int data){
        this->data = data;
        for(int i = 0;i<2;i++){
            child[i] = NULL;
        }
    }
};

class Trie{
    public:
    Node *root;
    Trie(){
        root = new Node('\0');
    }
    void insert(int num){  
        Node *prev = root;
        for(int i = 31;i>=0;i--){ // inserting a 32 bit integer starting from the 
            int bit = (num>>i)&1;
            Node*child;
            if(prev->child[bit]== NULL){
                child = new Node(bit);
                prev->child[bit] = child; // pushes the bit at 0 if bit is 0, 1 if the bit is 1
            }
            else{
                child = prev->child[bit];
            }
            prev = child;
        }
    }

    int find_max(int num){
        int val = 0;
        Node *prev = root;
        for(int i = 31;i>=0;i--){
            int bit = (num>>i)&1;
            Node *child;
            if (bit & 1){
                if(prev->child[0]){ 
                    child = prev->child[0];
                    val = val |(1<<i); 
                }
                else{
                    child = prev->child[1];
                }
            } 
            else{ // bit is 0
                if(prev->child[1]){
                    child = prev->child[1];
                    val = val |(1<<i);
                }
                else{
                    child = prev->child[0];
                }
            }
            prev = child;
        }
        return val;
    }
};



int maximumXor(vector<int> A)
{
    Trie t;
    for(int i = 0;i<A.size();i++){
        t.insert(A[i]);
    }
    int ans = 0;
    int val = 0;
    for(int i = 0;i<A.size();i++){
        val = t.find_max(A[i]);
        ans = max(ans,val);
    }
    return ans; 
    
}
-----------------------------



#include<bits/stdc++.h>

 

class Node{

    public:

    Node* links[2];

};

 

void insert(Node* root,int ele)

{

    int n=ele;

    Node* cur=root;

    for(int i=31;i>=0;i--)

    {

        int bit=(n>>i)&1;

        if(cur->links[bit]==NULL)

            cur->links[bit]=new Node();

        cur=cur->links[bit];

    }

}

 

int getmaxXOR(Node* root,int n)

    {

        int xr=0;

        Node* cur=root;

        for(int i=31;i>=0;i--)

        {

            int bit=(n>>i)&1;

            if(cur->links[1^bit]!=NULL)

            {

                xr+=(1<<i);

                cur=cur->links[1^bit];

            }

            else  

              cur=cur->links[bit];

 

        }

        return xr;

    }

 

vector<int> maxXorQueries(vector<int> &arr, vector<vector<int>> &queries){

    //  Write your coode here.

    Node* root=new Node();

    sort(arr.begin(),arr.end());

    vector<pair<int,pair<int,int>>> q;

    for(int i=0;i<queries.size();i++)

      q.push_back({queries[i][1],{queries[i][0],i}});

 

    sort(q.begin(),q.end());

    vector<int> ans(q.size());

    int idx=0;

    for(int i=0;i<q.size();i++)

    {

        int ai=q[i].first;

        int xi=q[i].second.first;

        int index=q[i].second.second;

        while(idx<arr.size() && arr[idx]<=ai)

        {

            insert(root,arr[idx]);

            idx++;

        }

        if(idx==0)

          ans[index]=-1;

        else

          ans[index]=getmaxXOR(root,xi);

    }

    return ans;

}


----------------------------
#include <bits/stdc++.h> 
// Stack class.
class Stack {
    
public:
    int * p=NULL, *h=NULL, *t=NULL, c;
    Stack(int capacity) {
        // Write your code here.
        p=new int[capacity+1]();
        this->c=capacity;
        h=p;
        
    }

    void push(int num) {
        // Write your code here.
        
        p++;
        *p=num;

    }

    int pop() {
        // Write your code here.
        if(p==h){
            return -1;
        }
        int n=*p;
        p--;
        return n;
    }
    
    int top() {
        // Write your code here.
        if(p==h){
            return -1;
        }
        return *p;
    }
    
    int isEmpty() {
        // Write your code here.
        if(h==p){
            return 1;
        }
        else{
            return 0;
        }
    }
    
    int isFull() {
        // Write your code here.
        if(p-h==c){
            return 1;
        }
        else{
            return 0;
        }
    }
    
};
-------------------------------
#include <bits/stdc++.h> 
struct Node{
    int f;
    Node* n=NULL;
   
    Node(int d){
        this->f=d;
    }
};
class Queue {
public:
Node* p=new Node(-1);
Node *h=p;
 
    Queue() {
        // Implement the Constructor
       

    }

    /*----------------- Public Functions of Queue -----------------*/

    bool isEmpty() {
        // Implement the isEmpty() function
        if(!h->n or h==p){
            
            return 1;
        }
        else{
            return 0;
        }
    }

    void enqueue(int data) {
        // Implement the enqueue() function
    Node* nw=new Node(data);
    p->n=nw;
    
    p=p->n;
   // cout<<p->f<<" ";
    }

    int dequeue() {
        // Implement the dequeue() function
        if(!h->n or h==p){
            return -1;
        }
        int r=h->n->f;
        Node* t= h->n;
       h->n=t->n;
       if(!h->n){
           p=h;
       }
        delete t;
       return r;
    }

    int front() {
        // Implement the front() function
         if(!h->n or h==p){
            return -1;
        }
return h->n->f;
    }
};
-------------------------------------
#include <bits/stdc++.h> 
class Stack {
	// Define the data members.
    private:
        queue<int> q1;
        queue<int> q2;
        int length;

    public:
    Stack() {
        // Implement the Constructor.
        length = 0;
    }

    /*----------------- Public Functions of Stack -----------------*/

    int getSize() {
        return length;
    }

    bool isEmpty() {
        return length == 0;
    }

    void push(int element) {
        q2.push(element);
        while(!q1.empty()){
            q2.push(q1.front());
            q1.pop();
        }
        swap(q1, q2);
        length++;
}

    int pop() {
        if(!q1.empty()){
            int value = q1.front();
            q1.pop();
            length--;
            return value;
        }
        return -1;
    }

    int top() {
        if(!q1.empty()){
            return q1.front();
        }
        return -1;
    }
};
-------------------------------------

#include<stack>
class Queue {
   // Make 2 stacks ans size
   stack<int>s1;
   stack<int>s2;
   int size;
   
   public:
   Queue() {
       // Initialize your size structure here.
       size = 0;
   }

   void enQueue(int val) {
       // Enque or push operation

       // Push into stack 1 
       s1.push(val);

       // Update the size
       size++;
   }

   int deQueue() {
       // Dequeue or pop opeation
       
       int ans;
      // Step 1 : Chcek if s2 is empty or not
      if(!s2.empty())
      {
          ans = s2.top();
          s2.pop();
      }
      else
      {
          // If s2 is e,pty put all the elements from s1 to s2
          while(!s1.empty())
          {
               int val = s1.top();
               s1.pop();
               s2.push(val);   
          }
          
          // Again check if s2 is empty or not
          // if s1 was empty the s2 will also be empty
          if(!s2.empty())
          {
              ans = s2.top();
              s2.pop();
          }
          // If both are empty (s1, s2)
          else
          {
              return -1;
          }
      }
       size--;
       return ans;
   }

   int peek() {
       // if s2 is not empty then s2.top() is answer
      if(!s2.empty())
      {
          return s2.top();
      }
      else
      {
          // if both s1 and s2 is empty
          if(s1.empty())
          {
              return -1;
          }
          else
          {
              // if only s2 is empty
              while(!s1.empty())
              {
                  s2.push(s1.top());
                  s1.pop();
              }
              return s2.top();
          }
      }
   }


   bool isEmpty() {
       if(size == 0)
       {
           return true;
       }
       else
       {
           return false;
       }
   }
};


----------------------------------
bool isValidParenthesis(string e) {
  stack<char> s;
  for (int i = 0; i < e.length(); i++) {
    char ch = e[i];
    if (ch == '(' || ch == '{' || ch == '[')
      s.push(ch);
    else {
      if (!s.empty()) 
      {
        char top = s.top();
        if ((ch == '}' && top == '{') || (ch == ']' && top == '[') ||
            (ch == ')' && top == '(')) 
        {
                s.pop();
        }
        else
        {
            return  false;
        }
      }
      else{
          return false;
      }
    }
  }
  if(s.empty())
   return true;
   return false;
}
-------------------------
#include <bits/stdc++.h> 

vector<int> nextGreater(vector<int> &arr, int n) {
    // Write your code here
vector<int>v(n, -1);
stack<int>s;

s.push(arr[n-1]);
for(int i=n-2; i>=0; i--){
if(arr[i]<s.top()){
    v[i]=s.top();
    s.push(arr[i]);
}
else{
  while(!s.empty() and s.top()<=arr[i]){
      s.pop();
  }
    if(!s.empty()){
        v[i]=s.top();
    }
    s.push(arr[i]);
}
}
return v;

}
------------------------------
#include <bits/stdc++.h> 
void st(stack<int> &s){
if(s.size()==1){
	return;
}
int x=s.top();
s.pop();
st(s);
stack<int>t;
while(!s.empty() and s.top()>x){
t.push(s.top());
s.pop();
}
s.push(x);
while(!t.empty()){
	s.push(t.top());
	t.pop();
}
}
void sortStack(stack<int> &s)
{
	// Write your code here
	st(s);
}
--------------------------------
#include<bits/stdc++.h>
vector<int> nextSmallerElement(vector<int> &arr, int n)
{
    // Write your code here.
vector<int>v(n, -1);
stack<int>s;

s.push(arr[n-1]);
for(int i=n-2; i>=0; i--){
if(arr[i]>s.top()){
    v[i]=s.top();
    s.push(arr[i]);
}
else{
  while(!s.empty() and s.top()>=arr[i]){
      s.pop();
  }
    if(!s.empty()){
        v[i]=s.top();
    }
    s.push(arr[i]);
}

}
return v;
}

----------------------------------
#include<bits/stdc++.h>

 

class LRUCache

{

public:

class node{

 public:

 int key;

 int data;

 node* prev;

 node* next;

 node(int keyy,int dataa){

     key=keyy;

     data=dataa;

 }

 

};

node* head=new node(-1,-1);

node* tail=new node(-1,-1);

int cap;

 

unordered_map<int,node*> m;

    LRUCache(int capacity)

    {

        cap=capacity;

        head->next=tail;

        tail->prev=head;

        // Write your code here

    }

void deletee(node* temp){

    node* p=temp->prev;

    node* n=temp->next;

    p->next=n;

    n->prev=p;

 

}

void add(node* temp){

  node* p=head->next;

  head->next=temp;

  temp->next=p;

  p->prev=temp;

  temp->prev=head;

 

}

    int get(int key)

    {  if(m.find(key)!=m.end()){

        node* temp=m[key];

        int vl=temp->data;

      m.erase(key);

        deletee(temp);

        add(temp);

        m[key]=head->next;

        return vl;

        

 

    }

  return -1;

        // Write your code here

    }

 

    void put(int key, int value)

    {    if(m.find(key)!=m.end()){

        node *temp=m[key];

        m.erase(key);

        deletee(temp);

      

    }

     if(m.size()==cap){

        m.erase(tail->prev->key);

 

        deletee(tail->prev);

       

    }

    

    add(new node(key,value));

    m[key]=head->next;

 

    

 

    

        // Write your code here

    }

};


---------------------------------
#include <bits/stdc++.h> 
class node{
    public:
int d;
node *p=NULL, *n=NULL;
node(int data){
    this->d=data;
}
};
class LFUCache
{
public:
int i=0, c;
node *t=NULL, *cr=NULL;
unordered_map<int , int>mp;
unordered_map<int, node* >m;
    LFUCache(int capacity)
    {
        // Write your code here.
        c=capacity;
         t=new node(0);
         cr=t;

    }

    int get(int key)
    {
        // Write your code here.
        if(!mp[key]){
            return -1;
        }
        
        node* ch=m[key];
        if(ch==t){
            return mp[key];
        }
        ch->p->n=ch->n;
        ch->n=NULL;
        t->n=ch;
        ch->p=t;
        t=ch;
        m[key]=t;
        return mp[key];

    }

    void put(int key, int value)
    {
        // Write your code here.
        if(mp[key]){
            
            node* tp=m[key];
            if (tp!=t) {
              tp->p->n = tp->n;
              m[key]->n->p = tp->p;
              m[key]->n = NULL;
              t->n = m[key];
              m[key]->p = t;
              t = t->n;
              m[key]=t;
            }
            mp[key]=value;

        }
        else{
            
            if(i==c){
                mp[cr->n->d]=0;
            m[cr->n->d]=NULL;
            if(cr->n->n){
                cr->n=cr->n->n;

                cr->n->p=cr;
            }
            else{
                cr->n=NULL;
                t=cr;
            }
            }
            node* nn=new node(key);
            t->n=nn;
            nn->p=t;
            t=t->n;
            mp[key]=value;
            m[key]=nn;
            i++;
          //  cout<<i<<endl;

        }
    }
};

-----------------------------------------------------------------


 #include<bits/stdc++.h>
 void ns(vector < int > & h, vector < int > & hr, vector < int > & hl){
int i=0, c=0;
stack<int>l, r;
while(i<h.size()){
    while(!l.empty() and h[l.top()]>=h[i]){
l.pop();
    }
if(l.empty()){

  hl[i]=-1;
}
else{
  hl[i]=l.top();

}

l.push(i);
i++;
}

i=h.size()-1;

while(i>=0){
    while(!r.empty() and h[r.top()]>=h[i]){
r.pop();
    }
if(r.empty()){

  hr[i]=-1;
}
else{
  hr[i]=r.top();

}

r.push(i);
i--;
}

 }
 int largestRectangle(vector < int > & h) {
   // Write your code here.
vector < int >  l(h.size()), r(h.size());
ns(h,r, l);

/*
for(int i=0; i<h.size(); i++){
  cout<<l[i]<<" ";
}
cout<<endl;
for(int i=0; i<h.size(); i++){
  cout<<r[i]<<" ";
}
cout<<endl;
*/

int mz=INT_MIN;
for(int i=0; i<h.size(); i++){
  int le=0, re=0;
  if(l[i]==-1){
    le=i;
  }
  else{
    le=i-l[i]-1;
  }
  if(r[i]==-1){
    re=h.size()-1-i;
  }
  else{
    re=r[i]-i-1;
  }
  mz=max(mz, (re+le+1)*h[i]);
}
return mz;
 }
---------------------
#include <bits/stdc++.h>
vector<int> slidingWindowMaximum(vector<int> &nums, int &k) {
  vector<int> ans;
  deque<int> dq;
  int i = 0, j = 0;

  while (j < nums.size()) {
    while (!dq.empty() and nums[dq.back()] < nums[j])
      dq.pop_back();

    dq.push_back(j);

    if (j - i + 1 < k)
      j++;

    else if (j - i + 1 == k) {
      ans.push_back(nums[dq.front()]);

      if (nums[i] == nums[dq.front()])
        dq.pop_front();

      i++, j++;
    }
  }

  return ans;
}
---------------------------------
#include <bits/stdc++.h> 
// Implement class for minStack.
class minStack
{
	// Write your code here.
	
	public:
		vector<pair<int,int>>v;
		int i, mn=INT_MAX;;
		// Constructor
		minStack() 
		{ 
			// Write your code here.
			i=0;
		}
		
		// Function to add another element equal to num at the top of stack.
		void push(int num)
		{
			// Write your code here.
			if(num<mn){
				mn=num;
			}
		v.push_back({num, mn});
		i++;

		}
		
		// Function to remove the top element of the stack.
		int pop()
		{
			// Write your code here.
			if(i==0){
				return -1;
			}
			else{
				int x=v.back().first;
				v.pop_back();
				i--;
				if(i==0){
					mn=INT_MAX;
				}
				else{
					mn=v.back().second;
				}
				return x;
			}
		}
		
		// Function to return the top element of stack if it is present. Otherwise return -1.
		int top()
		{
			// Write your code here.
				if(i==0){
				return -1;
			}
			else{
				int x=v.back().first;
			
				return x;
			}
		}
		
		// Function to return minimum element of stack if it is present. Otherwise return -1.
		int getMin()
		{
			// Write your code here.
				if(i==0){
				return -1;
			}
			else{
				int x=v.back().second;
				
				return x;
			}
		}
};
----------------------------------
#include <bits/stdc++.h>
int f(vector<vector<int>>&grid,int n , int m)
{
    vector<vector<int>>visted(n,vector<int>(m,0));
    queue< pair<int,pair<int,int> > >q;
    int freshcount=0;
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<m;j++)
        {
            if(grid[i][j]==1)
            {
                freshcount++;
            }
            else if(grid[i][j]==2)
            {
                q.push({0,{i,j}});
                visted[i][j]=2;
            }
        }
    }
    int maxtime=0;
    int count=0;
    int r[]={0,1,0,-1};
    int c[]={-1,0,1,0};
    while(!q.empty())
    {
        auto p=q.front();
        q.pop();
        int time=p.first;
        int i=p.second.first;
        int j=p.second.second;
        maxtime=max(time,maxtime);
        for(int it=0;it<4;it++)
        {
           int nr=r[it]+i;
           int nc=c[it]+j;
           if(nr>=0 and nr<n and nc>=0 and nc<m)
           {
               if(!visted[nr][nc] and grid[nr][nc]==1)
               {
                   q.push({time+1,{nr,nc}});
                   visted[nr][nc]=2;
                   count++;
               }
           }
        }
    }
    if(freshcount!=count)
    {
        return -1;
    }
    return maxtime;
}
int minTimeToRot(vector<vector<int>>& grid, int n, int m)
{
   
    return f(grid,n,m);
}
-------------------------------------------------
#include <bits/stdc++.h> 
vector<int> findSpans(vector<int> &p) {
    // Write your code here.
    vector<int>r;
    stack<int>s;
    s.push(-1);
    s.push(0);
    r.push_back(1);
    for(int i=1; i<p.size(); i++){
        while(s.top()!=-1 and p[s.top()]<=p[i]){
            s.pop();
        }
        r.push_back(i-s.top());
        s.push(i);
    }
    return r;
}
---------------------------------
#include <bits/stdc++.h> 
vector<int> maxMinWindow(vector<int> a, int n) {
    // Write your code here.
    vector<int> nse(n), pse(n), res(n, INT_MIN);
    for(int i=0; i<n; i++)
    {
        pse[i] = i;
        nse[i] = n-i-1;
    }

    stack<int> stk;
    for(int i=0; i<n; i++)
    {
        while(!stk.empty() && a[stk.top()]>a[i])
        {
            nse[stk.top()] = i-stk.top()-1;
            stk.pop();
        }
        stk.push(i);
    }

    while(!stk.empty()) stk.pop();

    for(int i=n-1; i>=0; i--)
    {
        while(!stk.empty() && a[stk.top()]>a[i])
        {
            pse[stk.top()] = stk.top()-i-1;
            stk.pop();
        }
        stk.push(i);
    }

    for(int i=0; i<n; i++)
    {
        int d = nse[i]+pse[i];
        res[d] = max(res[d], a[i]);
    }

    for(int i=n-2; i>=0; i--)
    if (res[i]<res[i+1]) res[i] = res[i+1];

    return res;
}
--------------------------------
#include <bits/stdc++.h> 
/*
	This is signature of helper function 'knows'.
	You should not implement it, or speculate about its implementation.

	bool knows(int A, int B); 
	Function 'knows(A, B)' will returns "true" if the person having
	id 'A' know the person having id 'B' in the party, "false" otherwise.
*/

	int findCelebrity(int n) {
	stack<int> s;
	//step 1
	 for(int i=0;i<n;i++)
	  s.push(i);

	// step2
	while(s.size() > 1)
	{
		int a=s.top();
		s.pop();
		int b=s.top();
		s.pop();
		if(knows(a,b))
		 s.push(b);
		else
		 s.push(a);
	}
	int ans=s.top();

	// step 3
	int zerocount=0;
	for(int i=0;i<n;i++)
	{
		if(!knows(ans,i))
		 zerocount++;
	}
	if(zerocount != n)
	 return -1;
	
	// step 4
	int onecount=0;
	for(int i=0;i<n;i++)
	{
		if(knows(i,ans))
		onecount++;
	}
	if(onecount != n-1)
	 return -1;
	return ans;

}

--------------------------------
#include<bits/stdc++.h>
string reverseString(string &str){
	// Write your code here.
	stack<string>v;
	string r;
	string s="";
	int k=0, j=str.size()-1;
	while(str[k]==' '){
		k++;
	}
	while(str[j]==' '){
		j--;
	}

	for(int i=k; i<=j; i++){
		if(str[i] == 32){
			v.push(s);
			s="";
		}
		else{
			s+=str[i];
		}
	}	
	v.push(s);
	while(!v.empty()){
		r+=v.top();
		v.pop();
		r+=" ";
	}
	return r;
}
------------------------------
#include<bits/stdc++.h>

using namespace std;

 

int f(int i,int j,string &s){

    int n = s.size() , len = 0;

    while(i >= 0 && j < n && s[i--] == s[j++]) len += 2;

    return len;

}

 

string longestPalinSubstring(string s) {

   int n = s.size();

   int start = 0 , len = 0;

   for(int mid=0;mid<n;mid++){

       int odd = 1 + f(mid-1,mid+1,s);

       int even = f(mid,mid+1,s);

       if(len < odd) len = odd , start = mid-(odd/2);

       if(len < even) len = even , start = mid-(even/2)+1;

   }

   return s.substr(start,len);

}


-------------------------------------------
int romanToInt(string s) {
    // Write your code here
    int t=0;
    unordered_map<char,int>m;
    m['I']=0;
     m['V']=1;
      m['X']=2;
       m['L']=3;
        m['C']=4;
         m['D']=5;
          m['M']=6;

    for(int i=s.size()-1; i>=0; i--){
        int x;
         if(s[i]=='I'){
                x=1;
            }
            else if(s[i]=='V'){
                x=5;
            }
            else if(s[i]=='X'){
                x=10;
            }
            else if(s[i]=='L'){
                x=50;
            }
            else if(s[i]=='C'){
                x=100;
            }
            else if(s[i]=='D'){
                x=500;
            }
            else if(s[i]=='M'){
                x=1000;
            }
        if(i+1<s.size()){
            if(m[s[i]]<m[s[i+1]]){
                t-=x;
            }
            else{
                t+=x;
            }
        }
        else{
           t+=x;
        }
    }
    return t;
}
----------------------------
#include <bits/stdc++.h> 
int atoi(string str) {
    // Write your code here.
    int t=0, f=0;
    for(int i=0; i<str.size(); i++){
        if(str[i]>=48 and str[i]<=57){
            t*=10;
            t+=(str[i]-'0');
        }
        if(str[i]=='-'){
            f=1;
        }
    }
    if(f){
        t*=(-1);
    }
    return t;
}
-------------------------
typedef long long ll;
string longestCommonPrefix(vector<string> &arr, int n)
{
    // Write your code here
    string s;
    for(ll j=0; j<arr[0].size(); j++){
        char c=arr[0][j];
        ll f=0;
      for (ll i = 1; i < n; i++) {
          if(c!=arr[i][j]){
              f=1;
              break;
          }
      }
      if(!f){
          s+=c;
      }
      else{
          break;
      }
    }
    return s;
}



---------------------------------
vector<int> stringMatch(string text, string p) {
	// Write your code here.
	int i=0, s=text.find(p, i);
	vector<int>r;
	while(s!=-1){
		r.push_back(s+1);
		i=s+1;
		s=text.find(p, i);
	}
	return r;
}

---------------------------------

vector<int> computeLPS( string p, int m )
{
   int i = 1,
   len = 0;
   vector<int> lps(m,0);
   while ( i < m )
   {
       if ( p[i] == p[len] ){
           len++;
           lps[i] = len;
           i++;
       } else {
           if ( len != 0 ){
               len = lps[len-1];
           } else {
               lps[i] = 0;
               i++;
           }
       }
   }
   return lps;
}
int KMP( string s, string p ){
   int n = s.size(),m = p.size(),i = 0,j = 0, count = 0;         
       vector<int> lps = computeLPS(p,m);
   while ( i < n ){
       if ( s[i] == p[j] ){
           i++;
           j++;
       } else {
           if ( j != 0 ){
               j = lps[j-1];
           } else {
               i++;
           }
       }
       if ( j == m ){
           count++;
           j = lps[j-1];
       }
   }
   return count;
}
int zAlgorithm(string s, string p, int n, int m){ 
   return KMP(s,p);
}
----------------------------------
#include <bits/stdc++.h> 
typedef long long ll;
vector<ll>vc(string s){
    vector<ll>v(s.size(), 0);
    for(ll i=1; i<s.size(); i++){
        ll j=v[i-1];
    while(j>0 and s[i]!=s[j]){
        j=v[j-1];
    }
    if(s[i]==s[j]){
        j++;
    }
    v[i]=j;
    }
    return v;
}
bool findPattern(string p, string s)
{
    // Write your code here.

vector<ll>v=vc(p);
/*
for(ll i=0; i<v.size(); i++){
    cout<<v[i]<<" ";
}
*/
ll i=0, j=0, k=0;
while(i<s.size()){
if(s[i]==p[j]){
    i++;
    j++;
}
else{
    if(j!=0){
        j=v[j-1];
    }
    else{
        i++;
    }

}
if(j==p.size()){
    k++;
    j=0;

}
}
if(k){
    return true;
}
return false;
}
---------------------------
#include <bits/stdc++.h> 
typedef long long ll;
vector<ll>vc(string s){
    vector<ll>v(s.size(), 0);
    for(ll i=1; i<s.size(); i++){
        ll j=v[i-1];
    while(j>0 and s[i]!=s[j]){
        j=v[j-1];
    }
    if(s[i]==s[j]){
        j++;
    }
    v[i]=j;
    }
    return v;
}
bool findPattern(string p, string s)
{
    // Write your code here.

vector<ll>v=vc(p);
/*
for(ll i=0; i<v.size(); i++){
    cout<<v[i]<<" ";
}
*/
ll i=0, j=0, k=0;
while(i<s.size()){
if(s[i]==p[j]){
    i++;
    j++;
}
else{
    if(j!=0){
        j=v[j-1];
    }
    else{
        i++;
    }

}
if(j==p.size()){
    k++;
    j=0;

}
}
if(k){
    return true;
}
return false;
}
----------------------------------
#include<bits/stdc++.h>
int minCharsforPalindrome(string str) {
	int n = str.size();
	int i = 0, j = n - 1, count = 0, tempJ = j;
	while(i < j) {
		if(str[i] == str[j])
			i++, j--;
		else {
			count++;
			i = 0, tempJ--;
			j = tempJ;
		}
	}	
	return count;
}
------------------------------
#include <bits/stdc++.h> 
bool areAnagram(string &str1, string &str2){
    // Write your code here.
    sort(str1.begin(), str1.end());
    sort(str2.begin(), str2.end());
    if(str1==str2){
        return true;
    }
    else{
        return false;
    }
}
--------------------------
#include <bits/stdc++.h> 
string writeAsYouSpeak(int n) 
{
	// Write your code here.	
	if(n==1){
		return "1";
	}
	n--;
	string s="1";
	while(n--){
		char c=s[0];
		string z;
		int ct=0, i=0;
		while(i<s.size()){
                  while (i < s.size() and c == s[i]) {
                    i++;
                    ct++;
                  }
				  if(i<s.size() and c!=s[i]){
					  z+=(ct+'0');
					  z+=c;
					  c=s[i];
					  ct=0;
				  }
				  else if(i==s.size()){
					  z+=(ct+'0');
					  z+=c;
					  break;
				  }
                }
	s=z;
        }
		return s;
		
}
----------------------------
#include <bits/stdc++.h> 
typedef long long ll; 
int compareVersions(string a, string b) 
{
    // Write your code here
    int i=0, j=0;
    while(i<a.size() or j<b.size()){
        ll an=0, bn=0;
        while(i<a.size() and a[i]!='.'){
            an=(an*10)+(a[i]-'0');
            i++;
        }
        i++;
        while(j<b.size() and b[j]!='.' ){
            bn=(bn*10)+(b[j]-'0');
            j++;
        }
        j++;
        if(an>bn){
            return 1;
        }
        else if(an<bn){
            return -1;
        }
    }
    return 0;

}
----------------------------
#include <bits/stdc++.h> 
/*
    Following is Binary Tree Node structure:
    class TreeNode
    {
    public:
        int data;
        TreeNode *left, *right;
        TreeNode() : data(0), left(NULL), right(NULL) {}
        TreeNode(int x) : data(x), left(NULL), right(NULL) {}
        TreeNode(int x, TreeNode *left, TreeNode *right) : data(x), left(left), right(right) {}
    };
*/
void g(TreeNode* root, vector<int>& v){
    if(!root){
        return;
    }
    g(root->left, v);
    v.push_back(root->data);
    g(root->right, v);
}
vector<int> getInOrderTraversal(TreeNode *root)
{
    // Write your code here.
    vector<int>v;
    g(root, v);
    return v;
}
------------------------------
#include <bits/stdc++.h> 
/*
    Following is Binary Tree Node structure:
    class TreeNode
    {
    public:
        int data;
        TreeNode *left, *right;
        TreeNode() : data(0), left(NULL), right(NULL) {}
        TreeNode(int x) : data(x), left(NULL), right(NULL) {}
        TreeNode(int x, TreeNode *left, TreeNode *right) : data(x), left(left), right(right) {}
    };
*/
void g(TreeNode* root, vector<int>& v){
    if(!root){
        return;
    }
    v.push_back(root->data);
    g(root->left, v);
    
    g(root->right, v);
}
vector<int> getPreOrderTraversal(TreeNode *root)
{
    // Write your code here.
       vector<int>v;
    g(root, v);
    return v;
}
----------------------------------
#include <bits/stdc++.h> 
/*
    Following is Binary Tree Node structure:
    class TreeNode
    {
    public:
        int data;
        TreeNode *left, *right;
        TreeNode() : data(0), left(NULL), right(NULL) {}
        TreeNode(int x) : data(x), left(NULL), right(NULL) {}
        TreeNode(int x, TreeNode *left, TreeNode *right) : data(x), left(left), right(right) {}
    };
*/
void g(TreeNode* root, vector<int>& v){
    if(!root){
        return;
    }
    g(root->left, v);
   
    g(root->right, v);
     v.push_back(root->data);
}
vector<int> getPostOrderTraversal(TreeNode *root)
{
    // Write your code here.
    vector<int>v;
    g(root, v);
    return v;
}
-------------------------------------------------
#include <bits/stdc++.h> 
/************************************************************

    Following is the TreeNode class structure

    template <typename T>
    class TreeNode {
       public:
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/
void g(TreeNode<int> *root, vector<int>&v, unordered_map<int,int>&m, int i){
    if(!root){
        return;
    }
    if(m[i]==0){
        m[i]=1;
        v.push_back(root->data);
    }
    g(root->left, v, m, i+1);
    g(root->right, v, m, i+1);
}
vector<int> getLeftView(TreeNode<int> *root)
{
    //    Write your code here
    vector<int>v;
    unordered_map<int,int>m;
    g(root, v, m,0);
    return v;
}
--------------------------------
#include <bits/stdc++.h> 
/*************************************************************
 
    Following is the Binary Tree node structure.

    class BinaryTreeNode 
    {
    public : 
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
    };

*************************************************************/
void g(BinaryTreeNode<int> *root, map<int,int>&m,unordered_map<int,int>&mp, int i, int k){
    if(!root){
        return;
    }
    if (mp[i] <= k) {
      m[i] = root->data;
      mp[i]=k;
    }
    g(root->left,  m, mp, i-1, k+1);
    g(root->right, m, mp, i+1, k+1);
}
vector<int> bottomView(BinaryTreeNode<int> * root){

    // Write your code here.
     vector<int>v;
   map<int,int>m;
   unordered_map<int,int>mp;
    g(root,  m, mp, 0, 0);
    for(auto& q: m){
        v.push_back(q.second);
    }
    return v;
}

----------------------------------
#include <bits/stdc++.h> 
/************************************************************

    Following is the TreeNode class structure:

    template <typename T>
    class TreeNode {
       public:
        T val;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T val) {
            this->val = val;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/
void g(TreeNode<int> *root, map<int,int>&m,unordered_map<int,int>&mp, int i, int k){
    if(!root){
        return;
    }
    if(i==0 and m[i]==0){
m[i] = root->val;
    }
   else if (i!=0 and ( mp[i]==0 or  mp[i] >= k)) {
      m[i] = root->val;
      mp[i]=k;
    }
    g(root->left,  m, mp, i-1, k+1);
    g(root->right, m, mp, i+1, k+1);
}
vector<int> getTopView(TreeNode<int> *root) {
    // Write your code here.
       vector<int>v;
   map<int,int>m;
  unordered_map<int,int>mp;
    g(root,  m, mp, 0, 0);
    for(auto& q: m){
        v.push_back(q.second);
    }
    return v;
}
---------------------------------
#include <bits/stdc++.h> 
/************************************************************

    Following is the Binary Tree node structure:

    class BinaryTreeNode
    {
    public :
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
    };


************************************************************/
void ini(BinaryTreeNode<int> *r, vector<int>& v){
    if(!r){
        return ;
    }
   
    ini(r->left, v);
    v.push_back(r->data);
    ini(r->right, v);
     
}
void post(BinaryTreeNode<int> *r, vector<int>& v){
    if(!r){
        return ;
    }
   
    post(r->left, v);
    post(r->right, v);
     v.push_back(r->data);
}
void pre(BinaryTreeNode<int> *r, vector<int>& v){
    if(!r){
        return ;
    }
    v.push_back(r->data);
    pre(r->left, v);
    pre(r->right, v);
}
vector<vector<int>> getTreeTraversal(BinaryTreeNode<int> *root){
    // Write your code here.
    vector<vector<int>>v;
    vector<int>t;
    ini(root, t);
    v.push_back(t);
    t.clear();
     pre(root, t);
    v.push_back(t);
    t.clear();
     post(root, t);
    v.push_back(t);
    return v;
}
-------------------------
#include<bits/stdc++.h>
class Node{
    public:
    TreeNode<int>* node;
    int X;
    int Y;
    Node(TreeNode<int>* Node , int x,int y){
        node = Node;
        X = x;
        Y = y;
    }
};
vector<int> verticalOrderTraversal(TreeNode<int> *root)
{
    // node,x,y;
    queue<Node> q;
    vector<int> ans;
    map<int,vector<int>> travesal;
    Node n(root,0,0);
    q.push(n);
    while(!q.empty()){
        Node curr = q.front();
        q.pop();
        TreeNode<int>* temp = curr.node;
        int x = curr.X;
        int y = curr.Y; 
        travesal[x].push_back(temp->data);
        if(temp->left != NULL){
            Node tempL = Node(temp->left,x-1,y+1);
            q.push(tempL);
        }
        if(temp->right != NULL){
            Node tempR = Node(temp->right,x+1,y+1);
            q.push(tempR);
        }
    }

    for(auto it : travesal){
        for(auto i : it.second){
            ans.push_back(i);
        }
    }

    return ans;
}
---------------------------
#include <bits/stdc++.h> 
/*   
    template <typename T = int>
	class TreeNode
	{
		public:
		T data;
		TreeNode<T> *left;
		TreeNode<T> *right;

		TreeNode(T data)
		{
			this->data = data;
			left = NULL;
			right = NULL;
		}

		~TreeNode()
		{
			if (left != NULL)
			{
		  		delete left;
			}
			if (right != NULL)
			{
			 	delete right;
			}
		}
	};
*/
void f(vector<int>&v, TreeNode<int> *r, int x, int& ff){
	if(!r){
		return;
	}
	if(x==r->data){
		ff++;
		v.push_back(x);
		return;
	}
	v.push_back(r->data);
	f(v, r->left, x, ff);
	if(ff){
		return;
	}
	f(v, r->right, x, ff);
	if(ff){
		return;
	}
	v.pop_back();
}

vector<int> pathInATree(TreeNode<int> *r, int x)
{
    // Write your code here.
	
vector<int>v;
int ff=0;
	f(v, r, x, ff);
return v;
}

----------------------------
int getMaxWidth(TreeNode<int> *root)

{

    if (!root)

    return 0;

  int ans = 0;

  queue <TreeNode<int> * > q;

  q.push( root);

  while (!q.empty())

   {

    int size = q.size();

    ans=max(ans,size);

 

    for (int i = 0; i < size; i++) {

     TreeNode<int> * temp = q.front();

      q.pop();

     

      if (temp -> left)

        q.push(temp -> left);

      if (temp -> right)

        q.push(temp -> right);

    }

  }

  return ans;

}
-----------------------------------



#include <bits/stdc++.h> 
/************************************************************

    Following is the BinaryTreeNode class structure

    template <typename T>
    class BinaryTreeNode {
       public:
        T val;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T val) {
            this->val = val;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/
vector<int> getLevelOrder(BinaryTreeNode<int> *root)
{
    //  Write your code here.
    queue<BinaryTreeNode<int> *>q;
    q.push(root);
    vector<int>v;
    if(root==NULL){
        return v;
    }
    
    while(q.size()){
        int sz=q.size();
        
        for(int i=0; i<sz; i++){
            BinaryTreeNode<int> * f=q.front();
            v.push_back(f->val);
            q.pop();
            if(f->left){
                q.push(f->left);

            }
            if(f->right){
                q.push(f->right);
            }
        }

    }
    return v;
}
--------------------
#include <bits/stdc++.h>
using namespace std;

class Temp {
public:
    int height;
    int leftIndex;
    int rightIndex;

    Temp(int h, int li, int ri) {
        height = h;
        leftIndex = li;
        rightIndex = ri;
    }
};

int heightOfTheTree(vector<int>& inorder, vector<int>& levelOrder, int N){
    int maxHeight = 0;
    queue<Temp> q;

    if(N >= 1) {
        Temp temp(0, 0, N - 1);
        q.push(temp);
    }
    unordered_map<int, int> map;
    for(int i = 0;i < N; i++) {
        map[inorder[i]] = i;
    }

    for(int i = 0;i < N; i++) {
        Temp temp = q.front();
        q.pop();

        maxHeight = max(temp.height, maxHeight);

        int li = temp.leftIndex;
        int ri = temp.rightIndex;
        int rootIndex;

        rootIndex = map[levelOrder[i]];

        if(rootIndex - 1 >= li) {
            Temp leftSubTree(temp.height + 1, li, rootIndex - 1);
            q.push(leftSubTree);
        }

        if(rootIndex + 1 <= ri) {
            Temp rightSubTree(temp.height + 1, rootIndex + 1, ri);
            q.push(rightSubTree);
        }
    }

    return maxHeight;
}
--------------------
/************************************************************

    Following is the TreeNode class structure

    template <typename T>
    class TreeNode {
       public:
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/

int height(TreeNode<int> *node, int & diameter)
{
    if(!node)
    return  0;

    int lh=height(node->left,diameter);
    int rh=height(node->right, diameter);
    diameter=max(diameter, lh+rh);
    return 1+max(lh,rh);
}
int diameterOfBinaryTree(TreeNode<int> *root)
{
	// Write Your Code Here.
    int diameter=0;
    height(root, diameter);
    return diameter;
}

------------------------
#include <bits/stdc++.h> 
/*************************************************************
 
    Following is the Binary Tree node structure

    class BinaryTreeNode 
    {
    public : 
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
    };

*************************************************************/
pair<bool, int> chk(BinaryTreeNode<int>* t){
    if(!t){
        return {true, 0};
    }
    auto l=chk(t->left);
    auto r=chk(t->right);
    if(l.first and r.first and abs(l.second-r.second)<=1){
        return {true, 1+max(l.second, r.second)};
    }
    else{
        return {false, 1+max(l.second, r.second)};
    }
}
bool isBalancedBT(BinaryTreeNode<int>* root) {
    // Write your code here.
    auto a=chk(root);
    return a.first;
}
-----------------------------
#include <bits/stdc++.h> 
/************************************************************

    Following is the TreeNode class structure

    template <typename T>
    class TreeNode {
       public:
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/
int f(int& ans, TreeNode<int> *r, int&x, int&y){
    if(!r){
        return 0;
    }
    int o=0;
    int l=f(ans, r->left, x, y);
    int rr=f(ans, r->right, x, y);
    if(r->data==x or r->data==y){
        o=1;
    }
    if(o+l+rr==2){
        ans=r->data;
        return 1;
    }
    else{
        return o+l+rr;
    }
}
int lowestCommonAncestor(TreeNode<int> *root, int x, int y)
{
	//    Write your code here
    int ans;
     int l=f(ans, root, x, y);
     return ans;
    
}
--------------------------
#include <bits/stdc++.h> 
/**********************************************************

    Following is the Binary Tree Node class structure:

    template <typename T>

    class BinaryTreeNode {
    public :
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;
		
        BinaryTreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
    };

***********************************************************/
typedef BinaryTreeNode<int>* t;
bool i(t r1, t r2){
    if(!r1 and !r2){
        return true;
    }
    else if((r1 and !r2) or (r2 and !r1)){
        return false;
    }
    bool a, b, c;
    a=r1->data==r2->data;
    b=i(r1->left, r2->left);
    c=i(r1->right, r2->right);
    return a&b&c;
}
bool identicalTrees(BinaryTreeNode<int>* root1, BinaryTreeNode<int>* root2) {
    // Write your code here. 	 
    return i(root1, root2);
}
-----------------------
vector<int> zigZagTraversal(BinaryTreeNode<int> *root)
{
     vector<int> result;
        queue<BinaryTreeNode<int>*>q;
        
        bool lefttoright=true;
        
        if(root==NULL)
            return result;
        
        q.push(root);
        
        while(!q.empty())
        {
            int n=q.size();
            vector<int>sub(n);
            for(int i=0;i<n;i++)
            {
                BinaryTreeNode<int>* curr=q.front();
                q.pop();
                
                int index=lefttoright?i:n-i-1;
                sub[index]=curr->data;
               
                if(curr->left!=NULL)
                    q.push(curr->left);
                if(curr->right!=NULL)
                    q.push(curr->right);
            }
             
            lefttoright=!lefttoright;
            for(auto i:sub)
            {
                result.push_back(i);
            }
            
        }
        return result;
}

----------------------------
bool isLeaf(TreeNode<int>* root){
    return (root->left==NULL && root->right==NULL);
}
void addLeftBoundary(TreeNode<int>*root,vector<int>&ans){
    TreeNode<int>*node=root->left;
    
    while(node){
        if(!isLeaf(node)) ans.push_back(node->data);
        if(node->left) node=node->left;
        else node=node->right;
    }
}
void addLeaves(TreeNode<int>*root,vector<int>& ans){
    if(isLeaf(root)){
        ans.push_back(root->data);
        return;
    }
    if(root->left) addLeaves(root->left,ans);
    if(root->right) addLeaves(root->right,ans);

}
void addRightBoundary(TreeNode<int>*root,vector<int>&ans){
    vector<int> temp;
    TreeNode<int>*node=root->right;

    while(node){
        if(!isLeaf(node)) temp.push_back(node->data);
        if(node->right) node=node->right;
        else node=node->left;
    }

    for (int i=temp.size()-1;i>=0;i--){
    ans.push_back(temp[i]);
    }


}
vector<int> traverseBoundary(TreeNode<int>* root){
    vector<int> ans;
    if(!root) return ans;
    if(!isLeaf(root))ans.push_back(root->data);
    addLeftBoundary(root,ans);
    addLeaves(root,ans);
    addRightBoundary(root,ans);
    return ans;


}
---------------------------------
#include <bits/stdc++.h> 
/**********************************************************

    Following is the Binary Tree Node class structure:

    template <typename T>

    class BinaryTreeNode {
    public :
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;
		
        BinaryTreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
    };

***********************************************************/
typedef BinaryTreeNode<int>* t;
bool i(t r1, t r2){
    if(!r1 and !r2){
        return true;
    }
    else if((r1 and !r2) or (r2 and !r1)){
        return false;
    }
    bool a, b, c;
    a=r1->data==r2->data;
    b=i(r1->left, r2->left);
    c=i(r1->right, r2->right);
    return a&b&c;
}
bool identicalTrees(BinaryTreeNode<int>* root1, BinaryTreeNode<int>* root2) {
    // Write your code here. 	 
    return i(root1, root2);
}
---------------------------
vector<int> zigZagTraversal(BinaryTreeNode<int> *root)
{
     vector<int> result;
        queue<BinaryTreeNode<int>*>q;
        
        bool lefttoright=true;
        
        if(root==NULL)
            return result;
        
        q.push(root);
        
        while(!q.empty())
        {
            int n=q.size();
            vector<int>sub(n);
            for(int i=0;i<n;i++)
            {
                BinaryTreeNode<int>* curr=q.front();
                q.pop();
                
                int index=lefttoright?i:n-i-1;
                sub[index]=curr->data;
               
                if(curr->left!=NULL)
                    q.push(curr->left);
                if(curr->right!=NULL)
                    q.push(curr->right);
            }
             
            lefttoright=!lefttoright;
            for(auto i:sub)
            {
                result.push_back(i);
            }
            
        }
        return result;
}

---------------------------------
bool isLeaf(TreeNode<int>* root){
    return (root->left==NULL && root->right==NULL);
}
void addLeftBoundary(TreeNode<int>*root,vector<int>&ans){
    TreeNode<int>*node=root->left;
    
    while(node){
        if(!isLeaf(node)) ans.push_back(node->data);
        if(node->left) node=node->left;
        else node=node->right;
    }
}
void addLeaves(TreeNode<int>*root,vector<int>& ans){
    if(isLeaf(root)){
        ans.push_back(root->data);
        return;
    }
    if(root->left) addLeaves(root->left,ans);
    if(root->right) addLeaves(root->right,ans);

}
void addRightBoundary(TreeNode<int>*root,vector<int>&ans){
    vector<int> temp;
    TreeNode<int>*node=root->right;

    while(node){
        if(!isLeaf(node)) temp.push_back(node->data);
        if(node->right) node=node->right;
        else node=node->left;
    }

    for (int i=temp.size()-1;i>=0;i--){
    ans.push_back(temp[i]);
    }


}
vector<int> traverseBoundary(TreeNode<int>* root){
    vector<int> ans;
    if(!root) return ans;
    if(!isLeaf(root))ans.push_back(root->data);
    addLeftBoundary(root,ans);
    addLeaves(root,ans);
    addRightBoundary(root,ans);
    return ans;


}
------------------------------------
#include <bits/stdc++.h> 
/************************************************************

    Following is the Tree node structure
	
	template <typename T>
    class TreeNode 
    {
        public : 
        T val;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T val) 
        {
            this -> val = val;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/
typedef long long int ll;
typedef TreeNode<int> * t;
ll s(t r, ll & ans){
    if(!r){
        return 0;
    }
    ll l=s(r->left, ans);
    ll rr=s(r->right, ans);
    ans=max(ans, r->val+l+rr);
    return r->val+max(l, rr);
}
long long int findMaxSumPath(TreeNode<int> *root)
{
    if(!root or !root->left or !root->right ){
        return -1;
    }
    ll ans=0;
    ll z=s(root, ans);
    return ans;
}
-----------------------------
#include <bits/stdc++.h> 
/************************************************************

    Following is the TreeNode class structure

    template <typename T>
    class TreeNode {
       public:
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/
typedef TreeNode<int> * t;
typedef vector<int> vi;
t s(vi& ino,vi& pre, int st, int en, int& tr, unordered_map<int,int>&m){
if(st>en or tr>=ino.size()){
    return NULL;
}
int z=m[pre[tr]];
t nn=new TreeNode<int>(pre[tr]);
tr++;
if(st==en){
    return nn;
}
nn->left=s(ino, pre, st, z-1, tr, m);
nn->right=s(ino, pre, z+1, en, tr, m);
return nn;

}
TreeNode<int> *buildBinaryTree(vector<int> &inorder, vector<int> &preorder)
{
    unordered_map<int,int>m;
    for(int i=0; i<inorder.size(); i++){
        m[inorder[i]]=i;
    }
    int tr=0;
    return s(inorder, preorder, 0, inorder.size()-1, tr, m);
	
}
---------------------------------------
/************************************************************
   
   Following is the TreeNode class structure
   
   class TreeNode<T>
   { 
   public:
        T data; 
        TreeNode<T> *left;
        TreeNode<T> *right;
   
        TreeNode(T data) 
  		{ 
            this -> data = data; 
            left = NULL; 
            right = NULL; 
        }
   };
   
   
 ************************************************************/
typedef TreeNode<int> * t;
typedef vector<int> vi;
#include<bits/stdc++.h>
t s(vi& ino,vi& pre, int st, int en, int& tr, unordered_map<int,int>&m){
if(st>en or tr<0){
    return NULL;
}
int z=m[pre[tr]];
t nn=new TreeNode<int>(pre[tr]);
tr--;
if(st==en){
    return nn;
}
nn->right=s(ino, pre, z+1, en, tr, m);
nn->left=s(ino, pre, st, z-1, tr, m);

return nn;

}
TreeNode<int>* getTreeFromPostorderAndInorder(vector<int> &preorder, vector<int> &inorder) 
{
	// Write your code here.
      unordered_map<int,int>m;
    for(int i=0; i<inorder.size(); i++){
        m[inorder[i]]=i;
    }
    int tr=inorder.size()-1;
    return s(inorder, preorder, 0, inorder.size()-1, tr, m);
	
}

--------------------
/*****************************************************

    Following is the Binary Tree node structure:
    
    class BinaryTreeNode {
        public : 
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
        
        ~BinaryTreeNode() {
            if(left) 
                delete left;
            if(right) 
                delete right;
        }
    };

******************************************************/
typedef BinaryTreeNode<int>* t;
bool s(t a, t b){
if(!a and !b){
    return true;
}
else if(!a){
    return false;
}
else if(!b){
    return false;
}
bool l=s(a->left, b->right);
bool r=s(a->right, b->left);
return l and r and a->data==b->data;
}
bool isSymmetric(BinaryTreeNode<int>* root)
{
    // Write your code here.    
    return s(root, root);

}
--------------------
#include <bits/stdc++.h> 
/************************************************************

    Following is the TreeNode class structure.

    template <typename T>
    class TreeNode {
        public:
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/
void helper(TreeNode<int>*root,TreeNode<int>*&prev)

{

    if(!root)return;

    helper(root->right,prev);

    helper(root->left,prev);

    root->right=prev;

    root->left=NULL;

    prev=root;

}

TreeNode<int> *flattenBinaryTree(TreeNode<int> *root)

{

    TreeNode<int>*prev=NULL;

    helper(root,prev);

    return prev;

}
------------------------------
#include <bits/stdc++.h> 
/************************************************************

    Following is the TreeNode class structure

    template <typename T>
    class TreeNode {
       public:
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/
typedef TreeNode<int> * t;
void s(t r, t p, t l, bool& q, t& ans){
    if(!r){
        return;
    }
    if(r->data==l->data){
        r->left=p;
        q=1;
        ans=r;
        return;
    }
    s(r->left, r, l, q, ans);
    if(q){
      
            r->left=p;
       return;
    }
    s(r->right, r, l, q, ans);
    if(q){
       if(r->left){
           r->right=r->left;
       }
       else{
           r->right=NULL;
       }
            r->left=p;
            return;
       
    }
}
TreeNode<int> * invertBinaryTree(TreeNode<int> *r, TreeNode<int> *l)
{
	// Write your code here.
    bool q=0;
    t ans=NULL;
    s(r, NULL, l, q, ans);
    return ans; 
}

----------------------------------
#include <bits/stdc++.h> 
/*************************************************************

    Following is the Binary Tree node structure

    class BinaryTreeNode
    {
    public :
        T data;
        BinaryTreeNode < T > *left;
        BinaryTreeNode < T > *right;

        BinaryTreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
    };

*************************************************************/
typedef BinaryTreeNode < int > * t;
void s(t r){
    if(!r){
        return;
    }
    if(!r->left and !r->right){
        return;
    }
    int a=0, b=0;
    if(r->left){
        a=r->left->data;
    }
    if(r->right){
        b=r->right->data;
    }
    if(r->data<(a+b)){
        r->data=(a+b);
    }
    else if(r->data>(a+b)){
        if(r->left){
            r->left->data=r->data-b;
        }
        else if(r->right){
        
            r->right->data=r->data-a;
        }
    }
    s(r->left);
    s(r->right);
    if(r->left){
        a=r->left->data;
    }
    if(r->right){
        b=r->right->data;
    }
    if(r->data<(a+b)){
        r->data=(a+b);
    }
    

}
void changeTree(BinaryTreeNode < int > * root) {
    // Write your code here.
    s(root);
}  
---------------------------
#include <bits/stdc++.h> 
/*
    ----------------- Binary Tree node class for reference -----------------

    template <typename T>
    class BinaryTreeNode {
        public : 
            T data;
            BinaryTreeNode<T> *left;
            BinaryTreeNode<T> *right;
            BinaryTreeNode<T> *next;

            BinaryTreeNode(T data) {
                this -> data = data;
                left = NULL;
                right = NULL;
                next = NULL;
            }
    };
*/

#include <bits/stdc++.h>

void connectNodes(BinaryTreeNode<int> *root) {
  if (!root)
    return;

  queue<BinaryTreeNode<int> *> q;
  q.push(root);

  while (!q.empty()) {
    int n = q.size();
    while (n--) {
      auto p = q.front();
      q.pop();

      p->next = n ? q.front() : NULL;
      if (p->left)
        q.push(p->left);
      if (p->right)
        q.push(p->right);
    }
  }
}
-------------------------
#include <bits/stdc++.h> 
/*
    Following is the Binary Tree node structure:

    class BinaryTreeNode {
    public : 
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
    };
*/
typedef BinaryTreeNode<int> * t;
bool d(t r, int& x){
    if(!r){
        return false;
    }
    if(r->data==x){
        return true;
    }
    if(d(r->left, x) or d(r->right, x)){
        return true;
    }
}
bool searchInBST(BinaryTreeNode<int> *root, int x) {
    // Write your code here.
    return d(root, x);
}
---------------------
#include <bits/stdc++.h> 
/************************************************************

    Following is the TreeNode class structure

    template <typename T>
    class TreeNode {
       public:
        T val;
        TreeNode<T> *left;
        TreeNode<T> *right;
        
        TreeNode(T val) {
            this->val = val;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/
#include <bits/stdc++.h>

TreeNode<int> *constructTree(vector<int> &arr, int low, int high) {
  if (low > high)
    return NULL;

  int mid = (low + high) / 2;
  TreeNode<int> *root = new TreeNode<int>(arr[mid]);

  root->left = constructTree(arr, low, mid - 1);
  root->right = constructTree(arr, mid + 1, high);

  return root;
}

TreeNode<int> *sortedArrToBST(vector<int> &arr, int n) {
  return constructTree(arr, 0, n - 1);
}
----------------------------
#include <bits/stdc++.h> 
/*************************************************************

    Following is the Binary Tree node structure

    template <typename T>

    class TreeNode{
    public:
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }
        ~TreeNode() {
            if (left){
                delete left;
            }
            if (right){
                delete right;
            }
        }
    };

*************************************************************/
TreeNode<int>* m(vector<int> &p, int& i, int l, int h){
    if(i==p.size()){
        return NULL;
    }
    
    TreeNode<int>* c=NULL;
    if(i<p.size()){
        c=new TreeNode<int>(p[i]);
        i++;
    }
    
    if(i<p.size() and  p[i]>=l and p[i]<c->data){
        c->left=m(p, i, l, c->data);
       
    }
     if(i<p.size() and p[i]>=c->data and p[i]<h){
        c->right=m(p, i, c->data+1, h);
       
    }
    return c;
    
    
}
TreeNode<int>* preOrderTree(vector<int> &p){

int i=0;
return m(p, i, INT_MIN, INT_MAX);
    
}
----------------------
#include <bits/stdc++.h> 
/*************************************************************
 
    Following is the Binary Tree node structure

    class BinaryTreeNode 
    {
    public : 
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
    };

*************************************************************/
bool val(BinaryTreeNode<int> *r){
    if(!r){
        return true;
    }
    int l=INT_MIN, rr=INT_MAX;
    if(r->left){
        l=r->left->data;
    }
    if(r->right){
        rr=r->right->data;
    }
    return l<=r->data and rr>=r->data and val(r->left) and val (r->right);

}
bool validateBST(BinaryTreeNode<int> *root) {
    return val(root);
}
-------------------------------------------------------
#include <bits/stdc++.h> 
/************************************************************
    Following is the Binary Search Tree node structure
    
    template <typename T>
    class TreeNode {
        public :
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }

        ~TreeNode() {
            if(left)
                delete left;
            if(right)
                delete right;
        }
    };

************************************************************/
TreeNode<int>* val(TreeNode<int>* p, TreeNode<int>* q, TreeNode<int>* r){
    if(!r or !p or !q){
        return NULL;
    }
    
    if(p->data<r->data and q->data<r->data){
        return val(p, q, r->left);
    }
    else if(p->data>r->data and q->data>r->data){
        return val(p, q, r->right);
    }
    else{
        return r;
    }
}
TreeNode<int>* LCAinaBST(TreeNode<int>* root, TreeNode<int>* P, TreeNode<int>* Q)
{
	// Write your code here
    return val(P, Q, root);
}

---------------------------------
#include <bits/stdc++.h> 
/*************************************************************

    Following is the Binary Tree node structure

    template <typename T>

    class BinaryTreeNode
    {
    public :
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }

        ~BinaryTreeNode() {
            if (left)
            {
                delete left;
            }
            if (right)
            {
                delete right;
            }
        }
    };

*************************************************************/
typedef  BinaryTreeNode<int>* t;
void val(t r, int&k, int& l, int& a, bool& b){
    if(! r or b){
        return;
    }
    if(r->data==k){
      if(r->left) {
        t w=r->left;
         while(w->right){
             w=w->right;
         }
         l=w->data;
      }
      if(r->right){
          t w=r->right;
         while(w->left){
             w=w->left;
         }
         a=w->data;
      }
      b=1;
      return;
    }
    else{
        if(k>r->data){
            l=r->data;
            val(r->right, k, l, a, b);
        }
        else{
            a=r->data;
            val(r->left, k, l, a, b);
        }
        
    }
    
} 
pair<int,int> predecessorSuccessor(BinaryTreeNode<int>* root, int key)
{
    // Write your code here.
    int l=-1, a=-1;
    bool b=false;
    val(root, key, l, a, b);
    return { l, a };
}

----------------------------
#include <bits/stdc++.h> 
/************************************************************

    Following is the TreeNode class structure

    template <typename T>
    class TreeNode {
       public:
        T val;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T val) {
            this->val = val;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/
typedef TreeNode<int> * t;
void v(t r, int&X, int& ans){
    if(!r){
        return;
    }
    if(r->val==X){
        ans=X;
        return;
    }
    if(X>r->val){
        ans=r->val;
        v(r->right, X, ans);
    }
    else{
        
        v(r->left, X, ans);

    }

}
int floorInBST(TreeNode<int> * r, int X)
{
    // Write your code here.
    int ans;
    v(r, X, ans);
    return ans;
}
---------------------
#include <bits/stdc++.h> 
/************************************************************

    Following is the TreeNode class structure:

    class BinaryTreeNode {
    public:
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;
        
        BinaryTreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }
        
        ~BinaryTreeNode() {
            if (left) {
              delete left;
            }
            if (right) {
              delete right;
            }
        }
    };

************************************************************/
typedef BinaryTreeNode<int> * t;
void v(t r, int&X, int& ans){
    if(!r){
        return;
    }
    
    if(X>r->data){
       
        v(r->right, X, ans);
    }
    else{
         ans=r->data;
        v(r->left, X, ans);

    }

}
int findCeil(BinaryTreeNode<int> *r, int X){
    // Write your code here.
    int ans=-1;
    v(r, X, ans);
    return ans;
}
---------------------------
#include <bits/stdc++.h> 
/************************************************************
    Following is the Binary Search Tree node structure
    
    template <typename T>
    class TreeNode {
        public :
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }

        ~TreeNode() {
            if(left)
                delete left;
            if(right)
                delete right;
        }
    };

************************************************************/
typedef TreeNode<int>* t;
void val(t r, int&k, int& ans){
    if(!r or k==0){
        return;
    }
   
    
    
   
    val(r->right, k, ans);
    if(ans!=-1){
        return;
    }
        k--;
         if(k==0){
        ans=r->data;
        return;
    }
    
     val(r->left, k, ans);
}
int KthLargestNumber(TreeNode<int>* r, int k) 
{
    // Write your code here.
    int ans=-1;
   
    val(r, k, ans);
    return ans;
}

-------------------------
#include <bits/stdc++.h> 
/************************************************************

    Following is the TreeNode class structure

    template <typename T>
    class TreeNode {
       public:
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/
typedef TreeNode<int> * t;
void val(t r, int&k ,int&ans){
if(!r){
    return;
}
val(r->left,k, ans);
if(ans!=-1){
    return;
}
k--;
if(k==0){
    ans=r->data;
}
val(r->right,k, ans);

}
int kthSmallest(TreeNode<int> *r, int k)
{
    int ans=-1;
    val(r,k, ans);
	return ans;
}
----------------------------
#include <bits/stdc++.h> 
/**********************************************************

    Following is the Binary Tree Node structure:

    template <typename T>
    class BinaryTreeNode {
        public: 
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }

        ~BinaryTreeNode() {
            if (left)
                delete left;
            if (right)
                delete right;
        }
    };
***********************************************************/
bool solve(BinaryTreeNode<int> *root,unordered_set<int> &st,int &k){

    if(root==NULL)

    return false;

    if(solve(root->left,st,k)) return true;

 

    if(st.find(k- root->data)!=st.end())

    return true;

    st.insert(root->data);

    

    if(solve(root->right,st,k)) return true;

    return false;

}

bool pairSumBst(BinaryTreeNode<int> *root, int k)

{

    unordered_set<int> st;

    return solve(root,st,k);

}
------------------------------------
#include <bits/stdc++.h> 
/************************************************************

    Following is the TreeNode class structure

    template <typename T>
    class TreeNode {
       public:
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/


class BSTiterator
{
    stack<TreeNode<int>*> st;

public:
    BSTiterator(TreeNode<int>* root)
    {
        while(root)
        {
            st.push(root);
            root = root->left;
        }
    }

    int next()
    {
        TreeNode<int>* top = st.top();
        st.pop();

        TreeNode<int>* temp = top->right;

        while(temp)
        {
            st.push(temp);
            temp = temp->left;
        }

        return top->data;
    }

    bool hasNext()
    {
        return (!st.empty());
    }
};
/*
    Your BSTIterator object will be instantiated and called as such:
    BSTIterator iterator(root);
    while(iterator.hasNext())
    {
       print(iterator.next());
    }
*/
------------------------------------------
#include <bits/stdc++.h> 
/************************************************************

    Following is the Binary Tree node structure
    
    template <typename T>
    class TreeNode {
        public :
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }

        ~TreeNode() {
            if(left)
                delete left;
            if(right)
                delete right;
        }
    };

************************************************************/
typedef TreeNode<int>* t;
pair<int,int> p(t n, int& ans, int& a, int& b){
    if(!n){
        return {1 , 0};
    }
    int r=INT_MAX, l=INT_MIN;
    if(n->left){
        l=n->left->data;
    }
     if(n->right){
        r=n->right->data;
    }
    int lm=0, rm=INT_MAX, lmx=0, rmx=INT_MAX;
    auto lc=p(n->left, ans, lm, lmx);
    auto rc=p(n->right, ans, rm, rmx);
    if(!n->left and !n->right){
        a=n->data;
        b=n->data;
    }
    if(rm>n->data and rmx>n->data and lm<n->data and lmx<n->data and l<n->data and lc.first and rc.first ){
        ans=max(ans, lc.second+rc.second+1);
        if(n->left and n->right){
            b=rmx;
             a=lm;
            
        }
        if(n->left){
            a=lm;
            b=max(lmx, n->data);
        }
        else if(n->right){
            b=rmx;
            a=min(n->data, rm);
        }
        
        
        return {1, lc.second + rc.second + 1};
    } else {
        ans=max(ans, 1);
      return {0 , 1};
    }
}
int largestBST(TreeNode<int>* root) 
{
    // Write your code here.
    int ans=0, l=INT_MIN, r=INT_MAX;
    auto z= p(root, ans, l, r);
    return ans;
}

-----------------------------------
/************************************************************

    Following is the TreeNode class structure

    template <typename T>
    class TreeNode {
       public:
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/

string serializeTree(TreeNode<int> *root)
{
 //    Write your code here for serializing the tree
 
     if(!root) {
        return "#";
    }
    string ans=to_string(root->data)+",";
    string l=serializeTree(root->left);
    string r=serializeTree(root->right);
    return ans+l+r;

}
TreeNode<int>* helper(string &serialized,int &index) {
    if(index>=serialized.length() || serialized[index]=='#') {
        index++;
        return NULL;
    }
    int num=0;
    while(index<serialized.length() && serialized[index]>='0' && serialized[index]<='9') {
        num=(num*10)+(serialized[index]-'0');
        index++;
    }
    TreeNode<int>* root = new TreeNode<int>(num);
    index++;
    root->left=helper(serialized,index);
    root->right=helper(serialized,index);
    return root;
}
TreeNode<int>* deserializeTree(string &serialized) {
    int index=0;
    return helper(serialized,index);
}




---------------------------
#include <bits/stdc++.h> 
/*************************************************************
 
    Following is the Binary Tree node structure

    class BinaryTreeNode 
    {
    public : 
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
    };

*************************************************************/
typedef BinaryTreeNode<int>* b;
void sol(b& p, b r){
    if(!r){
        return ;
    }
    sol(p, r->left);
    p->right=r;
    r->left=p;
    p=r;
    
    sol(p, r->right);

}
BinaryTreeNode<int>* BTtoDLL(BinaryTreeNode<int>* r) {
    // Write your code here
    b t=new BinaryTreeNode<int>(1);
    b p=t;
    
    sol(p, r);
    return t->right;
    
}
---------------------------
#include<bits/stdc++.h>

vector<int> findMedian(vector<int> &arr, int n){   
vector<int>medians;  
priority_queue<int>maxh;  
priority_queue<int,vector<int>,greater<int>>minh;

    for(int i=0;i<n;i++)     {    
maxh.push(arr[i]);       
minh.push(maxh.top());    
maxh.pop();

       if(maxh.size()<minh.size()){      
maxh.push(minh.top());     
minh.pop();      
}

       int median; 
if(maxh.size()>minh.size()){    
median=maxh.top();       
}      
else{       
median=(maxh.top()+minh.top())/2;       
}      
medians.push_back(median);  
}    
return medians; 
}  
------------------------------------------
#include <bits/stdc++.h> 
class Kthlargest {
public:
priority_queue<int, vector<int>, greater<int>>p;
    Kthlargest(int k, vector<int> &arr) {
       // Write your code here.
        int i=0;
        while(i<k){
            
            p.push(arr[i]);
            i++;
        }
        while(i<arr.size()){
            if(arr[i]>p.top()){
                p.pop();
                p.push(arr[i]);
            }
            i++;
        }
    }

    void add(int num) {
        
        if(num>p.top()){
                p.pop();
                p.push(num);
        }
    }

    int getKthLargest() {
      return p.top();
    }

};
-------------------------------
#include <bits/stdc++.h> 
vector<int> countDistinctElements(vector<int> &arr, int k) 
{
    // Write your code here
	unordered_map<int,int>m, vv;
    for(int i=0;i <k; i++){
        m[arr[i]]++;
                vv[arr[i]]++;

    }
    vector<int>v;
    int t=0;
    v.push_back(m.size());
     for(int i=k;i <arr.size(); i++){
         if(vv[arr[i]] and m[arr[i]]==0){
             t--;
         }
        m[arr[i]]++;
        vv[arr[i]]++;
        m[arr[i-k]]--;
        if(m[arr[i-k]]==0){
            t++;
        }
        v.push_back(m.size()-t);
    }
    return v;
}

-----------------------------
#include <bits/stdc++.h> 
int kthLargest(vector<int>& arr, int size, int k)
{
	// Write your code here.
	priority_queue<int, vector<int>, greater<int>>p;
	for(int i=0; i<k; i++){p.push(arr[i]);
	}
	for(int i=k; i<size; i++){
		if(arr[i]>p.top()){
			p.pop();
			p.push(arr[i]);
		}
		
	}
	return p.top();

}
------------------------------------
#include<bits/stdc++.h>
vector<vector<int>> floodFill(vector<vector<int>> &image, int x, int y, int n)
{
    // Write your code here.
    queue<pair<int,int>>q;
    q.push({x, y});
    int o=image[x][y];
    
    while(q.size()){
        auto a=q.front();
        q.pop();
        o=image[a.first][a.second];
        if(o==n){
            continue;
        }
        image[a.first][a.second]=n;
        int xx=a.first;
        int yy=a.second;
        if(xx-1>=0){
            if(image[xx-1][yy]==o){
                q.push({xx-1, yy});
            }
        }
        if(xx+1<image.size()){
 if(image[xx+1][yy]==o){
                q.push({xx+1, yy});
            }
        }
        if(yy-1>=0){
 if(image[xx][yy-1]==o){
                q.push({xx, yy-1});
            }
        }
        if(yy+1<image[0].size()){
if(image[xx][yy+1]==o){
                q.push({xx, yy+1});
            }
        }
    }
    return image;
}
------------------------------------
graphNode* rec(graphNode* node,map<graphNode*,graphNode*>&mp)
{
	graphNode* newNode= new graphNode(node->data);
	mp[node]=newNode;
	vector<graphNode*>v;
	for (auto it: node->neighbours)
	{
		if (mp.find(it)!=mp.end())
		{
			v.push_back(mp[it]);
		}
		else v.push_back(rec(it,mp));
	}
	newNode->neighbours=v;
	return newNode;
	
}
graphNode *cloneGraph(graphNode *node)
{
    map<graphNode*,graphNode*>mp;
	return rec(node,mp);
}
-------------------------------------
void dfs(vector<set<int>> &e, int i, vector<int>&vis, vector<int>&v){
    vis[i]++;
    v.push_back(i);
    for(auto& q: e[i]){
      
        if(!vis[q]){
            dfs(e, q, vis, v);
        
        }
    }
}
vector<vector<int>> depthFirstSearch(int V, int E, vector<vector<int>> &edges)
{
    // Write your code here 
    vector<set<int>>v(V, set<int>());
    for(auto& q: edges){
v[q[0]].insert(q[1]);
v[q[1]].insert(q[0]);
    }
    vector<int> vis(V, 0);
    vector<vector<int>>r;
    for(int i=0; i<V; i++){
        
         if(!vis[i]){
             vector<int>vv;
            dfs(v, i, vis, vv);
            r.push_back(vv);
        }
        
    }

return r;
}
------------------------
#include <bits/stdc++.h> 
vector<int> BFS(int vertex, vector<pair<int, int>> edges)
{
    // Write your code here
    vector<int>v, vis(vertex, 0);
   vector<set<int>>vv(vertex, set<int>());
   for(auto& q: edges){
       vv[q.first].insert(q.second);
       vv[q.second].insert(q.first);
   }
   queue<int>q;
   q.push(0);
   vis[0]++;
   while(q.size()){
       int x=q.front();
       q.pop();
     v.push_back(x);
      
       
       for(auto& t: vv[x]){
           if(!vis[t]){
               q.push(t);
               vis[t]++;
           }
       }
   }
   for(int i=0; i<vertex; i++){
       if(!vis[i]){
           v.push_back(i);
       }
   }
    return v;
}
-------------------------
#include<bits/stdc++.h>
bool dfs(vector<set<int>>& e, int i, int p, vector<int>&vis, vector<int>&dv){
    vis[i]++;
    dv[i]++;
    for(auto& q: e[i]){
        if(q==p){
            continue;
        }
        if(vis[q]){
          
            return true;
        }
        else{
            bool a=dfs(e, q, i, vis, dv);
if(a){
    
    return true;
}
        }
    }
    vis[i]--;
return false;
}
string cycleDetection (vector<vector<int>>& edges, int n, int m)
{
    // Write your code here.

vector<set<int>> v(n+1, set<int>());
for(auto& q: edges){
    v[q[0]].insert(q[1]);
    v[q[1]].insert(q[0]);
}
vector<int>vis(n+1, 0), dv(n+1, 0);
for(int i=1; i<=n; i++){
    if(!dv[i]){
        if( dfs(v, i, -1, vis, dv)){
            return "Yes";
        }
    }
}
return "No";
}

-----------------------------
#include<bits/stdc++.h>
bool dfs(vector<set<int>>& e, int i, vector<int>&vis, vector<int>&dv){
    vis[i]++;
    dv[i]++;
    for(auto& q: e[i]){
       
        if(vis[q]){
          
            return true;
        }
        else{
            bool a=dfs(e, q, vis, dv);
if(a){
    
    return true;
}
        }
    }
    vis[i]--;
return false;
}
/*
string cycleDetection (vector<vector<int>>& edges, int n, int m)
{
    // Write your code here.

vector<set<int>> v(n+1, set<int>());
for(auto& q: edges){
    v[q[0]].insert(q[1]);
    v[q[1]].insert(q[0]);
}
vector<int>vis(n+1, 0), dv(n+1, 0);
for(int i=1; i<=n; i++){
    if(!dv[i]){
        if( dfs(v, i, -1, vis, dv)){
            return "Yes";
        }
    }
}
return "No";
}
*/
int detectCycleInDirectedGraph(int n, vector < pair < int, int >> & edges) {
  // Write your code here.
  vector<set<int>> v(n+1, set<int>());
for(auto& q: edges){
    v[q.first].insert(q.second);
   // v[q.second].insert(q.first);
}
vector<int>vis(n+1, 0), dv(n+1, 0);
for(int i=1; i<=n; i++){
    if(!dv[i]){
        if( dfs(v, i, vis, dv)){
            return 1;
        }
    }
}
return 0;
}

--------------------------------
#include <bits/stdc++.h> 
void dfs(vector<set<int>> &e, stack<int>&s, int i, vector<int>&vis){
    vis[i]++;
for(auto& q: e[i]){
    if(!vis[q]){
        dfs(e, s, q, vis);
    }
}
s.push(i);
}
vector<int> topologicalSort(vector<vector<int>> &edges, int v, int e)  {
    // Write your code here
    stack<int>s;
    vector<set<int>> vv(v);
    vector<int>vis(v, 0);
    int mn=INT_MAX;
    for(auto& q: edges){
        vv[q[0]].insert(q[1]);
        mn=min(mn, q[0]);
    }
    if(mn==INT_MAX){
        return vis;
    }
    for(int i=0; i<v; i++){
        if(!vis[i]){
 dfs(vv, s, i, vis);
        }
    }
   
    for(int i=0; i<v ; i++){
        if(s.size()){
        vis[i]=s.top();
        s.pop();
        }
       
        
        
    }
    return vis;
    

}
-------------------------------------------
#include<queue>
int getTotalIslands(int** arr, int n, int m)
{
   // Write your code here.
vector<vector<int>>v(n, vector<int>(m, 1));
int t=0;
queue<pair<int,int>>q;
   for(int i=0; i<n; i++){
      for(int j=0; j<m; j++){
       if(arr[i][j] and v[i][j]){
          q.push({i, j});
          v[i][j]=0;
          t++;
       }
       while(q.size()){
          int x=q.front().first;
          int y=q.front().second;
          q.pop();
             if(x-1>=0 and arr[x-1][y] and v[x-1][y]){
               
               v[x-1][y]=0;
            }
            if(x+1<n and arr[x+1][y] and v[x+1][y]){
v[x+1][y]=0;
q.push({x+1, y});
            }
            if(y-1>=0 and arr[x][y-1] and v[x][y-1]){
v[x][y-1]=0;
q.push({x, y-1});
            }
            if(y+1<m and arr[x][y+1]  and v[x][y+1]){
v[x][y+1]=0;
q.push({x, y+1});
            }
            if(x-1>=0 and y-1>=0 and arr[x-1][y-1] and v[x-1][y-1]){
v[x-1][y-1]=0;
q.push({x-1, y-1});
            }
            if(x-1>=0 and y+1<m and arr[x-1][y+1]  and v[x-1][y+1]){
v[x-1][y+1]=0;
q.push({x-1, y+1});
            }
            if(x+1<n and y+1<m and arr[x+1][y+1] and  v[x+1][y+1]){
v[x+1][y+1]=0;
q.push({x+1, y+1});
            }
            if(x+1<n and y-1>=0 and arr[x+1][y-1] and v[x+1][y-1]){
v[x+1][y-1]=0;
q.push({x+1, y-1});
            }
       }
      
         
         
      }
   }
   return t;
}

--------------------------------------------------
#include <bits/stdc++.h>

bool isGraphBirpatite(vector<vector<int>> &edges) {


    int n =edges.size();

    vector<int>adj[n];

    vector<int>color(n,-1);

    for (int i = 0; i < n; i++) {

 

    for (int j = 0; j < n; j++) {

 

      if (edges[i][j]) {

 

        adj[i].push_back(j);

 

        adj[j].push_back(i);

      }

    }

        }

        queue<int>q;

    q.push(0);

    color[0]=0;

    while(!q.empty())

    {

        int node=q.front();

        q.pop();

        for(auto it:adj[node])

        {

            if(color[it]==-1)

            {  

                color[it]=!color[node];

                q.push(it);

                

            }

            else if(color[it]==color[node])

            {

                return false;

            }

 

            

        }

    }

 

    return true;

}
----------------------------
#include<bits/stdc++.h>

using namespace std;

void dfs(int node,vector<int> &vis,stack<int> &s,vector<int>adj[])

{

    vis[node]=1;

    for(auto it:adj[node])

    {

        if(!vis[it]){

            dfs(it,vis,s,adj);

        }

    }

    s.push(node);

}

void dfs2(int node,vector<int> &vis,

vector<int>adjT[],vector<int> &temp){

vis[node]=1;

temp.push_back(node);

for(auto it:adjT[node])

{

    if(!vis[it])dfs2(it,vis,adjT,temp);

}

}

vector<vector<int>> stronglyConnectedComponents(int n, vector<vector<int>> &edges)

{

       vector<int>adj[n],adjT[n];

        for(auto it:edges){

            adj[it[0]].push_back(it[1]);

        }

    //using toposort

    vector<int>vis(n,0);

    stack<int>s;

    for(int i=0;i<n;i++)

    {

        if(!vis[i]){

            dfs(i,vis,s,adj);

        }

    }

//reverse all the edges

        for(auto it:edges)

        {

           adjT[it[1]].push_back(it[0]);

        }

 

        for(int i=0;i<n;i++)vis[i]=0;

//make a dfs call

vector<vector<int>>scc;

while(!s.empty()){

    int node=s.top();

    s.pop();

    vector<int>temp;

    if(!vis[node])

    {

   dfs2(node,vis,adjT,temp);

    }

    scc.push_back(temp);

}

return scc;

}
----------------------------------
#include <bits/stdc++.h>

vector<int> dijkstra(vector<vector<int>> &vec, int vertices, int edges, int source) {

// Write your code here.

vector<int>dis(vertices,INT_MAX);

priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;

dis[source]=0;

vector<pair<int,int>> adj[vertices];

for(auto i:vec)

{

adj[i[0]].push_back({i[1],i[2]});

adj[i[1]].push_back({i[0],i[2]});

}

pq.push({0,source});

while(!pq.empty()){

int dist=pq.top().first;

int node=pq.top().second;

pq.pop();

for(auto it:adj[node]){

int ewt=it.second;

int adjNode=it.first;

if(dist+ewt<dis[adjNode]){

dis[adjNode]=dist+ewt;

pq.push({dis[adjNode],adjNode});

}

}

}

return dis;

}
--------------------------------
#include <bits/stdc++.h> 

int bellmonFord(int n, int m, int src, int dest, vector<vector<int>> &edges) {

    // Write your code here.

    vector<int>dist(n+1,1e9);

        dist[src]=0;

        for(int i=1;i<=n;i++){

            for(auto it:edges){

                int u=it[0];

                int v=it[1];

                int w=it[2];

                if(dist[u]!=1e9 && dist[u]+w <dist[v]){

                    dist[v]=dist[u]+w;

                }

            }

        }  

        for(auto it:edges){

            int u=it[0];

            int v=it[1];

            int w=it[2];

            if(dist[u]!=1e9 && dist[u]+w <dist[v]){

                return {-1};

            }

        }      

    return dist[dest];

}
-----------------------
int floydWarshall(int n, int m, int src, int dest, vector<vector<int>> &edges) {
            
        vector<vector<int>>dist(n,vector<int>(n,1e9));
        for(int i=0;i<n;++i){
            dist[i][i]=0;
        }
        for(auto it:edges){
            int u=it[0]-1;
            int v=it[1]-1;
            int wt=it[2];
        dist[u][v]=wt; 
        }
        for(int k=0;k<n;++k){
            for(int i=0;i<n;++i){
                for(int j=0;j<n;++j){
                    if(dist[i][k] !=1e9 and dist[k][j] !=1e9){
                        dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);
                    }
                }
            }
        }
        return dist[src-1][dest-1];
}
--------------------
#include <bits/stdc++.h> 
vector<pair<pair<int, int>, int>> calculatePrimsMST(int n, int m, vector<pair<pair<int, int>, int>> &g)
{
    vector<int>par(n+1,-1);
    vector<int>key(n+1,INT_MAX);
    vector<bool>mst(n+1,false);
    vector<vector<pair<int,int>>>adj(n+1);
    for (auto it:g)
    {
     adj[it.first.first].push_back({it.first.second,it.second});
     adj[it.first.second].push_back({it.first.first,it.second});
    }
    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;
    pq.push({0,1});
    key[1]=0;
    while(!pq.empty())
    {
        auto node=pq.top();
        pq.pop();
        int u=node.second;
        mst[u]=true;
        for (auto it:adj[u])
        {
            int v=it.first;
            int wt=it.second;
            if (mst[v]==false && wt<key[v])
            {
                key[v]=wt;
                par[v]=u;
                pq.push({key[v],v});
            }
        }

    }
    vector<pair<pair<int, int>, int>> ans;
    for (int i=2;i<=n;i++)
    {
        ans.push_back({{i,par[i]},key[i]});
    }
    return ans;
}
------------------------------
#include <bits/stdc++.h>

void update(vector<int> &rank,vector<int> &parent,int n){
	for(int i=1; i<=n; i++){
		rank[i]=0;
		parent[i]=i;
	}
}

int findParent(int node,vector<int> &parent){
	if(parent[node]==node){
		return node;
	}

	return parent[node]=findParent(parent[node],parent);

}


void unionSet(int u,int v,vector<int> &parent,vector<int> &rank){

	u=findParent(u,parent);
	v=findParent(v,parent);

	if(rank[u]>rank[v]){
		parent[v]=u;
	}
	else if(rank[u]<rank[v]){
		parent[u]=v;
	}
	else {
		parent[v]=u;
		rank[u]++;
	}
}

int kruskalMST(int n, int m, vector<vector<int>> &graph) {
	
	

	sort(graph.begin(),graph.end(),[](vector<int> a,vector<int> b){
		return a[2]<b[2];
	});
	


	vector<int> rank(n+1);
	vector<int> parent(n+1);

	update(rank,parent,n);
	int ans=0;

	for(int i=0; i<graph.size(); i++){
		int u=findParent(graph[i][0],parent);
		int v=findParent(graph[i][1],parent);
		int w=graph[i][2];

		if(u != v){
			ans+=w;
			unionSet(u,v,parent,rank);
		}

	}
	return ans;
}
---------------------




#include <bits/stdc++.h> 
int maximumProduct(vector<int> &arr, int n)
{
	// Write your code here
	int mx1=INT_MIN, mx2=INT_MIN, c1=0, c2=0;
	for(int i=0; i<=n-1; i++){
		if(c1==0){
			c1=arr[i];
		}
		else{
			c1*=arr[i];
		}
		if(c2==0){
			c2=arr[n-1-i];
		}
		else{
			c2*=arr[n-1-i];
		}
		mx1=max(mx1, c1);
		mx2=max(mx2, c2);
	}
	return max(mx1, mx2);
}

------------------------
#include<bits/stdc++.h>
int longestIncreasingSubsequence(int arr[], int n)
{
    // Write Your Code here
   vector<int>temp;

temp.push_back(arr[0]);

int len=1;

for(int i=1;i<n;i++)

{

if(arr[i]>temp.back())

{

temp.push_back(arr[i]);

len++;

}

else

{

int ind=lower_bound(temp.begin(),temp.end(),arr[i])-temp.begin();

temp[ind]=arr[i];

}

 

 

}

return len;
}

---------------
#include<bits/stdc++.h>
int ret(string& s, string& t, int i, int j, vector<vector<int>>&v){
	if(i==s.size() or j==t.size()){
		return 0;
	}
	if(v[i][j]!=-1){
		return v[i][j];
	}
	int a=s[i]==t[j]?1:0;
	
	int d= ret(s, t, i+1, j+1, v);
	if(a){
		return v[i][j]=a+d;
	}
	else{
int b=ret(s, t, i, j+1, v);
	int c=ret(s, t, i+1, j, v);
	return v[i][j]=max(c, b);
	}
	

}
int lcs(string s, string t)
{
	//Write your code here
	//vector<vector<int>>v(s.size(), vector<int>(t.size(), -1));
	//return ret(s, t, 0, 0, v);
	vector<vector<int>>dp(s.size()+1, vector<int>(t.size()+1, 0));
	int m=s.size();
	int n=t.size();
        for(int i=1;i<=m;i++)

        {

            for(int j=1;j<=n;j++)

            {

 

                if(s[i-1]==t[j-1])

                {

 

                    dp[i][j]=dp[i-1][j-1]+1;

                }

                else

                {

                   dp[i][j]= max(dp[i-1][j],dp[i][j-1]);

                }

            }

        }

        return dp[m][n];

}
---------------------
int mx(vector<int> &values, vector<int> &weights, int i, int w){
if(i==values.size()){
	return 0;
}
int a=0 , b=mx(values, weights, i+1, w);
if(w>=weights[i]){
a=values[i]+mx(values, weights, i+1, w-weights[i]);
}
return max(a, b);
}
int maxProfit(vector<int> &values, vector<int> &weights, int n, int w)
{
	// Write your code here
	//return mx(values, weights, 0, w) ;
	vector<vector<int>>v(n+1, vector<int>(w+1, 0));
	
	
	for(int i=1; i<=n; i++){
		for(int j=0; j<=w; j++){
			v[i][j]=v[i-1][j];
if(j>=weights[i-1]){
v[i][j]=max(v[i][j], values[i-1]+v[i-1][j-weights[i-1]]);
}
		}
	}
	return v[n][w];
}
------------------------------
#include<bits/stdc++.h>
int editDistance(string str1, string str2)
{
    //write you code here
    string s1="/", s2="/";
    s1+=str1;
    s2+=str2;
    vector<vector<int>>v(s1.size(), vector<int>(s2.size(), 0));
    
  for (int i = 0; i < s1.size(); i++)
    v[i][0] = i; 
    
  for (int i = 0; i < s2.size(); i++)
    v[0][i] = i; 
for(int i=1; i<=str1.size(); i++){
    for(int j=1; j<=str2.size(); j++){
        if(str1[i-1]==str2[j-1]){
            v[i][j]=v[i-1][j-1];
        }
        else{
            v[i][j]=1+min(v[i-1][j], min(v[i][j-1], v[i-1][j-1]));
        }
    }
}

return v[str1.size()][str2.size()];
}
----------------------
#include <bits/stdc++.h> 
int sol(vector<int> &rack, int n, int i, int p){
	if(i==n){
		return 0;
	}
	int b=0;
	if(p==-1 or rack[p]<rack[i]){
		b+=rack[i];
		b+=sol(rack, n, i+1, i);
	}
	return max(sol(rack, n, i+1, p), b);
}
int maxIncreasingDumbbellsSum(vector<int> &rack, int n)
{
	// Write your code here
	//return sol(rack, n, 0, -1);
		vector<int>dp(n,0);
    int ans=rack[0];
    if(n==1) return ans;
    dp[0]=rack[0];
    for(int i=1;i<n;i++){
        dp[i]=rack[i];
        for(int j=0;j<i;j++){
            if(rack[j]<rack[i]){
                dp[i]=max(dp[i],dp[j]+rack[i]);
            }
        }
        ans=max(ans,dp[i]);
    }
    return ans;
}
------------------------
#include <bits/stdc++.h> 

int helper(vector<int>&arr,int start,int end,vector<vector<int>>&dp) {
    if(start==end-1) {
        return dp[start][end]=0;
    }
    if(dp[start][end]!=-1) {
        return dp[start][end];
    }
    int ans=INT_MAX;
    for(int i=start+1;i<end;i++) {
        if(dp[start][i]==-1) {
            dp[start][i]=helper(arr,start,i,dp);
        }
        if(dp[i][end]==-1) {
            dp[i][end]=helper(arr,i,end,dp);
        }
        ans=min(ans,dp[start][i]+dp[i][end]+(arr[start]*arr[i]*arr[end]));
    }
    return dp[start][end]=ans;
}

int matrixMultiplication(vector<int> &arr, int N) {
    vector<vector<int>>dp(N+1,vector<int>(N+1,-1));
    return helper(arr,0,N-1,dp);
}
------------------------
#include <bits/stdc++.h> 
int sol(vector<vector<int>> &g, int i, int j){
    if(i==g.size()-1 and j==g[0].size()-1)
{
    return g[g.size()-1][g[0].size()-1];
    
}
else if(i==g.size() or j==g[0].size()){
    return INT_MAX;
} 
   return g[i][j]+min(sol(g, i+1, j), sol(g, i, j+1));
}
int minSumPath(vector<vector<int>> &g) {
    // Write your code here.
  //  return sol(g, 0 ,0);
  vector<vector<int>>v(g.size()+1, vector<int>(g[0].size()+1, INT_MAX));
v[0][0]=g[0][0];
    for(int i=0; i<g.size(); i++){
        for(int j=0; j<g[0].size(); j++){
            if(i==0 and j==0){
                continue;
            }
            int z=g[i][j];
         if(i-1>=0){
             v[i][j]=v[i-1][j];
         }
         if(j-1>=0){
             v[i][j]=min(v[i][j], v[i][j-1]);
         }
         v[i][j]+=z;
    }
    }
    return v[g.size()-1][g[0].size()-1];
}
----------------------------
#include<bits/stdc++.h>
long sol(int *d, int n,  int val, int i){
    if(val==0){
        return 1;
    }
    if(i==n){
        return 0;
    }
    long ans=sol(d, n, val, i+1);
    if(*(d+i)<=val){
        ans+=sol(d, n, val-(*(d+i)), i);
    }
    
    return ans;
}
long countWaysToMakeChange(int *d, int n, int value)
{
    //Write your code here
   // return sol(d, n, value, 0);
   vector<vector<long>>v(n, vector<long>(value+1, 0));
   for(int i=0; i<n; i++){
       v[i][0]=1;
   }
   for(int i=0; i<n; i++){
       for(int j=0; j<=value; j++){
         if (i - 1 >= 0) {
           v[i][j] = v[i - 1][j];
         }
           if (*(d + i) <= j) {
               v[i][j]+=v[i][j-*(d + i)];
           }
       }
   }
   return v[n-1][value];
}
-----------------------
#include <bits/stdc++.h> 
bool sol(int n, int k, vector<int> &a, int i){
   
    if(k==0){
        return true;
    }
     if(i==n){
        return false;
    }
    bool b=sol(n, k, a, i+1);
    if(k>=a[i]){
        return b or sol(n, k-a[i], a, i+1);
    }
    else{
        return b;
    }
}
bool subsetSumToK(int n, int k, vector<int> &arr) {
    // Write your code here.
  //  return sol(n, k, a, 0);

vector<vector<bool>> dp(n, vector<bool>(k+1, 0));


 

    for(int i=0; i<n; i++) dp[i][0]=true;

 

    dp[0][arr[0]] = true;

 int target=k;

    for (int index=1; index<n; index++){

        for (int target=1; target<=k; target++){

            

            //if (dp[index][target] != -1) return dp[index][target];

            bool notTake = dp[index-1][target];

 

            bool Take = false;

            if (arr[index]<=target) Take = dp[index-1][target-arr[index]];

 

            dp[index][target] = Take | notTake;

            

        }

    }return dp[n-1][k];

}
------------------------------
 int help(int idx, vector<int>&price, int target, vector<vector<int>>&dp){

    if(idx == 0){

        return (target/(idx+1))*price[0];

    } 

    if(dp[idx][target]!=-1) return dp[idx][target];

    int notpick = help(idx-1,price,target,dp);

    int pick = 0;

    if(idx+1 <=target)

    pick = price[idx] + help(idx,price,target-(idx+1),dp);

    return dp[idx][target] = max(pick,notpick);

}

int cutRod(vector<int> &price, int n)

{

    vector<vector<int>>dp(n+1,vector<int>(n+1,0));

  //  return help(n-1,price,n,dp);

  for(int i=1; i<=n; i++){
	  dp[1][i]=(price[0]*i);
  }
  for(int i=1; i<=n; i++){
	  for(int j=1; j<=n; j++){
		  int np=dp[i-1][j];
		  int p=0;
		  if(i<=j){
			  p=price[i-1]+dp[i][j-(i)];
		  }
		  dp[i][j]=max(p, np);
	  }
  }
  return dp[n][n];

}

--------------------------
#include<bits/stdc++.h>
int rec(int n,int k,vector<vector<int>>&dp)
{
    if (n<=0 || k<=0) return 0;
    if (k==1) return n;
    if (n==1) return 1;
    if (dp[n][k]!=-1) return dp[n][k];
    int ans=INT_MAX;
    int low=1;
    int high=n;
    while(low<=high)
    {
        int mid=low+(high-low)/2;
        int broken=rec(mid-1,k-1,dp);
        int notBroken=rec(n-mid,k,dp);
         int result=max(notBroken,broken);
        ans=min(result+1,ans);
        if (broken<notBroken)
        {
           low=mid+1;
        }
        else{
          high=mid-1;
        }
    }
    
    return dp[n][k]=ans;
}

int cutLogs(int k, int n)
{
   vector<vector<int>>dp(n+1,vector<int>(k+1,-1));
   return rec(n,k,dp);
}

-------------
#include <bits/stdc++.h> 
class Node{
    public:
    Node* links [26];
    bool flag=false;
    bool isContains(char ch)
    {
        return links[ch-'a']!=NULL;
    }
    void put(char ch,Node* node)
    {
        links[ch-'a']=node;
    }
    Node* get(char ch)
    {
        return links[ch-'a'];
    }
    bool isEnd()
    {
        return flag;
    }
    void setEnd()
    {
        flag=true;
    }
};
class Trie{
    public:
     Node* root;
    Trie()
    {
        root=new Node();
    }
    void insert(string & word)
    {
        Node* node=root;
        for (int i=0;i<word.size();i++)
        {
            if (!node->isContains(word[i]))
            {
                node->put(word[i],new Node());
            }
            node=node->get(word[i]);
        }
        node->setEnd();
    }
    bool search(string &target,int low,int high)
    {
        Node* node=root;
        for (int i=low;i<=high;i++)
        {
            if (!node->isContains(target[i])) return false;
            node=node->get(target[i]);
        }
        return node->isEnd();
    }
   bool helper(int ind,vector<int>&dp,string & target)
   {
       if (ind==target.size()) return true;
       if (dp[ind]!=-1) return dp[ind];
       for (int i=ind;i<target.size();i++)
       {
           if (search(target,ind,i) && helper(i+1,dp,target))
           return dp[ind]=1;
       }
       return dp[ind]=0;
   }
};
bool wordBreak(vector < string > & arr, int n, string & target) 
{
     Trie* trie=new Trie();
     for (int i=0;i<n;i++)
     {
         trie->insert(arr[i]);
     }
     int sz=target.size();
     vector<int>dp(sz,-1);
     return trie->helper(0,dp,target);
}
----------------------
#include <bits/stdc++.h> 

bool isPalindrome(string s) {
  string t = s;
  reverse(t.begin(), t.end());
  return s == t;
}
int palindromePartitioning(string str) {
    // Write your code here
      int n = str.size();

vector<int>dp(n, INT_MAX);
int ans=INT_MAX;
int ct=0;
  for (int i = 0; i <n; i++) {
    int mini = INT_MAX;
    for (int k = i; k < n; k++){
      if (isPalindrome(str.substr(i, k - i + 1))){
          if(i>0){
              mini = min(mini, 1 + dp[i-1]);
          }
          else{
              mini=1;
          }
          dp[k]=min(dp[k], mini);
          //cout<<k<<" "<<dp[k]<<endl;
      }
        

    }
    
    
  }

  return dp[n-1]-1;
}


------------------------------------EOF------------------------------------------------------------------------------------------------------------
